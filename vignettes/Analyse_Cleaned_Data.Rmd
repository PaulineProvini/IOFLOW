---
title: "Analyse Cleaned Data"
output: rmarkdown::html_vignette
description: >
  Start here to understand how the IOFLOW package works to process the data.
vignette: >
  %\VignetteIndexEntry{Analyze_Cleaned_Data}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---


This document shows how the different functions of the IOFLOW package are 
working together and how to generate the figures and tables associated with the 
manuscript. The cleaned data were generated using "process.R" as explained in the 
"Clean_Raw_Data" vignette.


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Libraries
```{r library, echo=TRUE, message=FALSE, warning=FALSE, eval=TRUE}
library(IOFLOW)

# library(here)
library(dplyr) # for pipe 
library(tibble) # for rowid_to_column
library(stringr) # for str_replace
library(purrr) # for map
# library(reshape2) # for the melt function 

# # to plot
library(ggplot2)
library(grid)
library(ggpubr)
library(viridis)

# for nice tables
library(kableExtra)

```

## Functions

Loading the package functions.

```{r functions, echo= TRUE, eval= TRUE}

devtools::load_all()

```

## Dataset

There are three main datasets coming from the **IOFLOW package**:

 1. Tracking data for density test of 19 water tracers.  
 2. Water and Food tracers data, refered to with "*WF*" suffix or prefix.  
 3. Rigid body data, refered to with "*RB*" suffix or prefix.    

The following script is based on functions we can call for one or more trials. For the waterflow analysis, there are: 

 - 7 sequences of Carp   
 - 6 sequences of Tilapia  
 
# Water tracers density test

### Design of water tracers
The water tracer had to fulfill two apparently contradictory requirements: 
1) being radio-opaque to be trackable on the x-ray videos  
2) being neutrally buoyant to passively follow the water trajectory. 
We used 0.40 mm-diameter nickel rod on which we thread 1.4 mm closed-cell foam 
spheres (expanded polystyrene). We cut the nickel rod on both sides of each foam
spheres to obtain the water tracers. The lightness of the foam counterbalanced 
the weight of the inserted nickel. 

### Test of water tracer density
We dropped 19 water tracers in the middle of a water column, filmed and 
extracted their trajectory, using ProAnalyst software (XCitex, Cambridge, MA, 
USA).  
We calculate the mean velocity of the tracer until stabilization and calculated
the water tracer density. We follow [Stoke's law](http://www.meracalculator.com/physics/fluid-mechanics/stokes-law.php) and 
used the following formula:   
$\rho_{particle}=(18\mu_{water}V_{mean})/gd^2 +\rho_{water}$ with:

- $\ g$ = 9.80665 m/s²  
- $\ d$ = 0.00067 m corresponding to the mean diameter of particles (calculated 
on the day of the experiment)
- $\rho_{water}$ = 998.2 $\ kg/m^3$
- $\mu_{water}$ = 0.0010016 $\ kg/(m·s)$  or 1.0016 mPa.s at 20°C, according to 
[IAPWS 2008 ref](http://www.viscopedia.com/viscosity-tables/substances/water/)

```{r density, echo= TRUE, eval= TRUE}
# DENSITY calculation

# Variable initialization
rho <- vector()
V_Mean <- vector()
V_Sd <- vector()

g <- 9.80665  #in m/s²
d <- 0.0006719836  # mean diameter of particles in m
rho_water <- 998.2  # in kg/m^3
mu_water <-  0.0010016  # in kg/(m·s) or 1.0016 mPa.s à 20°C data coming from 
# http://www.viscopedia.com/viscosity-tables/substances/water/


# Variable initialization in Density_Data

for (i in 1:length(Density_Data)) {
  # For each water tracer tested
  Density_Data [[i]]$Dist <- NA
  Density_Data [[i]]$Velocity <- NA
  
  # Distance and Velocity calculation
  for (j in 2:(nrow(Density_Data[[i]]))) {
    Density_Data [[i]][j, 5] <-
      sqrt((Density_Data [[i]][j, 3] - Density_Data [[i]][j - 1, 3]) ^ 2 +
             (Density_Data [[i]][j, 4] - Density_Data [[i]][j - 1, 4]) ^ 2)
    Density_Data [[i]][j, 6] <- Density_Data[[i]][j, 5] / 0.02 # Velocity
  }
  
  # Sequence cropping
  A <-  which(Density_Data [[i]][, 1] == 0) + 1
  B <-
    which(Density_Data [[i]][, 6] == 0 &
            Density_Data[[i]][, 1] > 0) [1] - 2
  
  Density_Data [[i]] <- Density_Data [[i]][A:B,]
  
  # Motion orientation
  if (Density_Data[[i]][2, 4] < 0) {
    V_Mean[i] <- mean(Density_Data[[i]][, 6])
  }
  else{
    V_Mean[i] <- -mean(Density_Data[[i]][, 6])
  }
  
  V_Sd[i] <- sd(Density_Data[[i]][, 6])
  
  # rho calculation
  rho[i] <- (18 * mu_water *  V_Mean[i]) / (g * d ^ 2) + rho_water
}

Result_density <-
  as.data.frame(
    cbind(
      rho = rho,
      V_Mean = V_Mean,
      V_Sd = V_Sd,
      g = g,
      d = d,
      rho_water = rho_water,
      mu_water = mu_water
    )
  )

```

We obtain a mean value of 
$\rho$ = `r round(mean(Result_density$rho), digits = 2) ` $\pm$ 
`r  round(x=sd(Result_density$rho), digits=2) `$kg/m^3$

The distance to $\rho_{water}$ = `r round(x=mean (Result_density$rho - Result_density$rho_water[1]), digits=2) ` $\pm$ 
`r round(x=sd(Result_density$rho-Result_density$rho_water[1]), digits=2)`
$kg/m^3$ 
The data distribution can be visualized in the following plot, with the 
horizontal line corresponding to $\rho_{water}$.  


```{r plot_rho, echo=FALSE}

Terminal_velocity <- ggplot(Result_density, aes(y = -V_Mean * 10 ^ 3, x = 1)) +
  geom_boxplot() +
  geom_errorbar(aes(
    ymin = -min(V_Mean - sd(V_Mean)) * 10 ^ 3,
    ymax = -max(V_Mean + sd(V_Mean)) * 10 ^ 3
  ),
  width = .2,
  position = position_dodge(.9)) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("velocity (mm/s)") +
  labs(subtitle = "Terminal velocity")

Density_estimation <- ggplot(Result_density, aes(y = rho, x = 1)) +
  geom_boxplot() +
  geom_errorbar(aes(ymin = min(rho - sd(rho)), ymax = max(rho + sd(rho))),
                width = .2,
                position = position_dodge(.9)) +
  ylab(expression(paste(rho, " in kg/", m ^ {3}))) +
  labs(subtitle = "Density estimation") +
  theme_minimal() +
  theme(legend.position = "none")

Terminal_velocity
Density_estimation


```

This plot corresponds to the Figure 8c and 8d in the manuscript. 

We considered that the density of water tracers was close enough to the density 
of water and therefore used them in the experiment.   
   
   


# Hydrodynamic mechanism

## Waterflow trajectory and velocity during a sequence of suction feeding

We plot the trajectory and velocity of the food (one item) with the mean and 
standard deviation of the water tracers over time by calling the plot_mean 
function. 
These plots correspond to the Figure 2 of the manuscript. 

### Example of C2P1T04 (Carp 2, one food item, trial 4):

```{r Figure2_carp, echo=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.show='hold',fig.align='center'}

# FIGURE 2  Full Sequence: TRAJECTORY and VELOCITY 

# C2P1T04: trial 4 of carp 2 (one prey)
trial <- "C2P1T04"
color <- c(palette_IOFLOW[13], # grey
           palette_IOFLOW[5]   # blue
) 

# Tx plot
xlab <- ""
ylab <- "x-position (cm)"
d <- cbind(rbind(Mean_tx_W[[trial]],Mean_tx_F[[trial]]), 
           timing = Timing[[trial]]$timing)
plot.Tx_C2P1T04 <- plot_mean(d, ylab=ylab, xlab = xlab,
                             color = color) + theme(plot.margin = unit(c(0,0,0,0), "lines"))

# Vx plot
xlab <- "time (s)"
ylab <- "x-velocity (cm/s)"
d <- cbind(rbind(Mean_vx_W[[trial]],Mean_vx_F[[trial]]), 
           timing = Timing[[trial]]$timing)

plot.Vx_C2P1T04 <- plot_mean(d, ylab=ylab, xlab=xlab, 
                             color = color) + theme(plot.margin = unit(c(0,0,0,0), "lines"))


# plot the combination of the two plots

ggarrange(plot.Tx_C2P1T04+ rremove("x.text") + rremove(object = "xlab") , plot.Vx_C2P1T04, labels = "Fig 2a. Carp",
         ncol = 1, nrow = 2, align = "v")



```

### Example of T1P1T06 (Tilapia 1, one food item, trial 6)

```{r Figure2_tilapia, echo=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.show='hold',fig.align='center'}

# FIGURE 2  Full Sequence: TRAJECTORY and VELOCITY 
# T1P1T06: trial 4 of carp 2 (one prey)
trial <- "T1P1T06"
color <- c(palette_IOFLOW[13], # grey
           palette_IOFLOW[5]   # blue
) 

# Tx plot
# xlab <- ""
ylab <- "x-position (cm)"
d <- cbind(rbind(Mean_tx_W[[trial]],Mean_tx_F[[trial]]), 
           timing = Timing[[trial]]$timing)

plot.Tx_T1P1T06 <- plot_mean(d, ylab=ylab, xlab=xlab, color = color)+ 
  theme(plot.margin = unit(c(0,0,0,0), "lines"))

# Vx plot
xlab <- "time (s)"
ylab <- "x-velocity (cm/s)"
d <- cbind(rbind(Mean_vx_W[[trial]],Mean_vx_F[[trial]]), 
           timing = Timing[[trial]]$timing)

plot.Vx_T1P1T06 <- plot_mean(d, ylab=ylab, xlab=xlab, color = color) + 
  theme(plot.margin = unit(c(0,0,0,0), "lines"))


# plot the combination of the two plots

ggarrange(plot.Tx_T1P1T06+ rremove("x.text") + rremove(object = "xlab") , plot.Vx_T1P1T06, labels = "Fig 2b. Tilapia",
         ncol = 1, nrow = 2, align = "v")


```



## Distance covered by Food vs Water tracers

We want to calculate the total distance covered by the water and food tracers 
(**WF**) at each frame, over a sequence of suction feeding. 
First, we store the iterative distance in a list we name **Distance_WF**.

```{r iterative_distance, echo=TRUE, message=FALSE, warning=FALSE}

# Calculate the iterative distance of all tracers for each frame
Distance_WF <-
  map(.x = Trials, .f = ~ sqrt((  WF_tx[[.]][] - lag(WF_tx[[.]][])) ^2 +
                                 (WF_ty[[.]][] - lag(WF_ty[[.]][])) ^2 +
                                 (WF_tz[[.]][] - lag(WF_tz[[.]][])) ^2)) %>%
  set_names(names(WF_tx))

# change the name of the variable ".tx" to ".dist"

Distance_WF <- mapply(FUN = data.frame,
                      map(Trials, ~ set_names(
                        x = Distance_WF[[.]][],
                        nm = str_replace(
                          string = names(Distance_WF[[.]][]),
                          pattern = "_data.tx",
                          replacement = ".dist"))),
                      SIMPLIFY = FALSE) %>% 
  set_names(names(WF_tx))

```


### Total distance for each tracer, cumulated on the entire sequence

Now, we can calculate the total distance covered by each tracer over the entire sequence, by summing the previously computed iterative distances. We name this 
variable **Sum_dist_WF**.

```{r cumulative_distance, echo=TRUE, message=FALSE, warning=FALSE}

Sum_dist_WF <-
  map(.x = Trials,
      .f = ~ Distance_WF[[.]] %>% 
        replace(is.na(.), 0) %>% 
        summarise_all(sum)) %>%
  set_names(names(WF_tx))

```


#### Average of the Total distance cumulated on the entire sequence

We compute the mean and standard deviation of the cumulative distance 
**Sum_dist_WF** for each species and each type of tracer (food and water).   
For the water tracers, the cumulative distance is averaged over all the water 
tracers of each trial.   
As there was one to three markers implanted in one food 
item, the standard deviation for the food tracers is low or corresponds to a
NA when only one marker remained.
We use the compute_species_item function to compute the mean and standard
deviation of the cumulative distance for each species and each type of tracer.


```{r compute_species_item, echo=TRUE, message=FALSE, warning=FALSE}

# Food tracers
Food <- map(.x = Trials, .f= ~select( Sum_dist_WF[[.]],
        names(Sum_dist_WF[[.]])[contains(match = "A",
                                         vars = names(Sum_dist_WF[[.]]))])
) %>% set_names(names(Maya_WF))

Carp_food     <- compute_species_item(species = "carp",
                       item = "food",
                       name = "Carp_food")

Tilapia_food  <- compute_species_item(species = "tilapia",
                       item = "food",
                       name = "Tilapia_food")


# Water tracers

Water <- map(.x = Trials, .f= ~select( Sum_dist_WF[[.]],
        names(Sum_dist_WF[[.]])[contains(match = "A",
                                         vars = names(Sum_dist_WF[[.]]))])
) %>% set_names(names(Maya_WF))

Carp_water    <- compute_species_item(species = "carp",
                       item = "water",
                       name = "Carp_water")
Tilapia_water <-compute_species_item(species = "tilapia",
                       item = "water",
                       name = "Tilapia_water")



```

For example, we obtain **Carp_food**, which is a list with the mean and 
standard deviation of the cumulative distance of each trial for the food item.

```{r Carp_food, echo=TRUE, message=FALSE, warning=FALSE}

glimpse(Carp_food[1:2])

```

We combine the food and water average and standard deviation, using the 
**tidy_data2** function.

```{r Mean_list_combination, echo=TRUE, message=FALSE, warning=FALSE}

Carp_names <- names(Sum_dist_WF)[starts_with(match = "C",
                                             vars = names(Sum_dist_WF))]
Carp_distance <- tidy_data2(Carp_names, Carp_food, Carp_water)

Tilapia_names <- names(Sum_dist_WF)[starts_with(match = "T",
                                                vars = names(Sum_dist_WF))]
Tilapia_distance <- tidy_data2(Tilapia_names, Tilapia_food, Tilapia_water)

```

For example, **Carp_distance** is a list with the mean and standard deviation 
of the cumulative distance of each trial for both the food and water tracers.

```{r Carp_distance, echo=TRUE, message=FALSE, warning=FALSE}

glimpse(Carp_distance[1])

```

#### Table with distance cumulated on the entire sequence 

We build a table with all the relevant information about the cumulative 
distance of food and water tracers.

```{r Table_mean_data, echo=TRUE, message=FALSE, warning=FALSE}

Carp_mean <- data.frame(
  mean = c(map_dbl(.x = Carp_names, .f = ~Carp_food[[.]]$Carp_food_mean ),
           map_dbl(.x = Carp_names, .f = ~Carp_water[[.]]$Carp_water_mean)),
  sd = c(rep(NA, length(Carp_names)),
         map_dbl(.x = Carp_names, .f = ~Carp_water[[.]]$Carp_water_sd)),
  species = 'Carp',
  trials = rep(Carp_names, 2), 
  item = c(rep("food", length(Carp_names)), rep("water", length(Carp_names))))

Tilapia_mean <- data.frame(
  mean = c(map_dbl(.x = Tilapia_names,
                   .f = ~Tilapia_food[[.]]$Tilapia_food_mean ),
           map_dbl(.x = Tilapia_names, 
                   .f = ~Tilapia_water[[.]]$Tilapia_water_mean)),
  sd = c(rep(NA, length(Tilapia_names)),
         map_dbl(.x = Tilapia_names, 
                 .f = ~Tilapia_water[[.]]$Tilapia_water_sd)),
  species = 'Tilapia',
  trials = rep(Tilapia_names, 2), 
  item = c(rep("food", length(Tilapia_names)),rep("water", 
                                                  length(Tilapia_names))))

```


Here is what **Carp_mean** looks like

```{r Carp_mean, echo=FALSE}

Carp_mean %>%
  kable() %>%
 kable_styling()

```

Here is what **Tilapia_mean** looks like

```{r Tilapia_mean, echo=FALSE}

Tilapia_mean %>%
  kable() %>%
kable_styling()

```


#### Histogram of the total distance covered by food and water tracers

We use the previous table to plot an histogram with the relevant variables. 
This histogram corresponds to a visualization of Table S1.

```{r Dist_histogram, echo=TRUE, fig.width=5, fig.show='hold',                             fig.align='center'}


carp_bar <-
  ggplot(data = Carp_mean, aes(x = trials, y = mean, fill = item)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = .2,
                position = position_dodge(0.9)) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("cumulative distance (cm)") +
  scale_color_manual(values = color) +
  scale_fill_manual(values =  color) +
  labs(title = "Total distance covered by food and water tracers", subtitle =
         "a. Carp")

tilapia_bar <-
  ggplot(data = Tilapia_mean, aes(x = trials, y = mean, fill = item)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = .2,
                position = position_dodge(0.9)) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("cumulative distance (cm)") +
  scale_color_manual(values = color) +
  scale_fill_manual(values =  color) +
  labs(subtitle = "b. Tilapia")


carp_bar
tilapia_bar


```

These histograms correspond to Fig. S2 in the manuscript. 
Note that the food tracers don't have any standard deviation bars because all 
the food markers were on the same food item.



## Phases during a suction feeding sequence

To automatically detect the different phases during a trial, we use a
combination of information about the water tracers velocity and trajectory.
We focus on the water tracers to determine the different phases.

### Data preparation

```{r Phase, echo=TRUE, message=FALSE, warning=FALSE}

# combine Mean_vx with Mean_tx in Mean_v_t_W
Frame <-  map(.x = Trials, 
              .f = ~ seq(from = 1, to = nrow(Mean_vx_W[[.]]))) %>%
  set_names(names(Maya_WF))

vx_names <- paste0(names(Mean_vx_W[[1]][]), "_vx")
Mean_vx_W_2 <- map(.x = Trials,
                   .f = ~ tibble(Mean_vx_W[[.]][]) %>% set_names(vx_names)) %>%
  set_names(names(Mean_vx_W))

tx_names <- paste0(names(Mean_tx_W[[1]][]), "_tx")
Mean_tx_W_2 <- map(.x = Trials,
                   .f = ~ tibble(Mean_tx_W[[.]][]) %>% set_names(tx_names)) %>%
  set_names(names(Mean_tx_W))

Mean_v_t_W <-  mapply(
  FUN = data.frame,
  Mean_vx_W_2,
  Mean_tx_W_2,
  frame = Frame,
  SIMPLIFY = FALSE)

# compute the lag between each row of Mean_v_t_W to obtain a trend (+ or -) 
#and add it to Mean_v_t_W

Phase <- map(.x = Trials,
             .f = ~ Mean_v_t_W[[.]] %>%
               mutate(diff_average_vx = average_vx - lag(average_vx)) %>%
               mutate(diff_average_tx = average_tx - lag(average_tx))) %>%
  set_names(names(Mean_v_t_W))


```

### Phases extraction 

We assign a label ("stasis", "reverse flow", "transport") associated with a given 
combination of value for average_vx, and diff_average_vx.

```{r}

Phase <-  map(.x = Trials,
              .f = ~ mutate(.data = Phase[[.]],
                            phase = 
                              case_when(
                                frame < Sequence$end_FS[[.]] &
                                frame > Sequence$beg_FS[[.]] ~ 1,#first strike
                                average_vx < 2 &
                                average_vx > -4.5 &
                                diff_average_vx < 0.3 &
                                diff_average_vx > -0.3 ~ 0,      #stasis
                                average_vx > 0.05 ~ -1,          #reverse flow
                                average_vx < 0.05 ~ 2)           #back flow
                            )) %>% 
  set_names(names(Mean_vx_W_2))


# Extract the phase list, corresponding to the previous labels for each trial
phase <-  map(.x = Trials,
              .f = ~ get_sublist(lst = Phase[[.]], group_name = "phase")) %>%
  set_names(names(Phase))

```


### Testing the phase extraction on one trial

We test the phase detection on the different trials. 
Here we chose "C2P1T04" that we used in Figure 2a.

```{r Phases, echo=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.show='hold',fig.align='center'}

# Test trial
trial <- "C2P1T04"

# Plot of the velocity trend (+ or -) over the trial

plot.Velocity_trend <- ggplot(data = Phase[[trial]],
                              aes(x = Timing[[trial]]$timing,
                                  y =  diff_average_vx)) +
  geom_hline(yintercept = 0.35) +
  geom_hline(yintercept = -0.35) +
  geom_point(aes(colour = as.factor(phase)), size = 1) +
  ylab("diff_vx") +
  xlab("time") +
  scale_color_manual(
    values = palette_IOFLOW,
    labels = c("reverse flow", "stasis", "first strike", "back flow"),
    name = "phase"
  ) +
  scale_fill_manual(values =  palette_IOFLOW) +
  labs(title = "Test Phase Detection C2P1T04") +
  theme_minimal()


plot.Velocity_mean <- ggplot(data = Phase[[trial]],
                             aes(x = Timing[[trial]]$timing,
                                 y = average_vx)) +
  geom_point(aes(colour = as.factor(phase)), size = 1) +
  ylab("vx") +
  xlab("time") +
  geom_hline(yintercept = -5) +
  geom_hline(yintercept = 2.5) +
  scale_color_manual(
    values = palette_IOFLOW,
    labels = c("reverse flow", "stasis", "first strike", "back flow"),
    name = "phase"
  ) +
  scale_fill_manual(values =  palette_IOFLOW) +
  theme_minimal()


plot.TrajectoryX_mean <- ggplot(data = Phase[[trial]],
                                aes(x = Timing[[trial]]$timing,
                                    y = average_tx)) +
  geom_point(aes(colour = as.factor(phase)), size = 1) +
  ylab("tx") +
  xlab("time") +
  scale_color_manual(
    values = palette_IOFLOW,
    labels = c("reverse flow", "stasis", "first strike", "back flow"),
    name = "phase"
  ) +
  scale_fill_manual(values =  palette_IOFLOW) +  
  theme_minimal()


plot.Velocity_trend
plot.Velocity_mean
plot.TrajectoryX_mean

```

We also teste the phase extraction on "T1P1T06", use in Fig. 2b.

```{r, echo=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.show='hold',fig.align='center'}
# Test trial
trial <- "T1P1T06"

# Plot of the velocity trend (+ or -) over the trial

plot.Velocity_trend <- ggplot(data = Phase[[trial]],
                              aes(x = Timing[[trial]]$timing,
                                  y =  diff_average_vx)) +
  geom_hline(yintercept = 0.35) +
  geom_hline(yintercept = -0.35) +
  geom_point(aes(colour = as.factor(phase)), size = 1) +
  ylab("diff_vx") +
  xlab("time") +
  scale_color_manual(
    values = palette_IOFLOW,
    labels = c("reverse flow", "stasis", "first strike", "back flow"),
    name = "phase"
  ) +
  scale_fill_manual(values =  palette_IOFLOW) +
  labs(title = "Test Phase Detection 'T1P1T06'") +
  theme_minimal()


plot.Velocity_mean <- ggplot(data = Phase[[trial]],
                             aes(x = Timing[[trial]]$timing,
                                 y = average_vx)) +
  geom_point(aes(colour = as.factor(phase)), size = 1) +
  ylab("vx") +
  xlab("time") +
  geom_hline(yintercept = -5) +
  geom_hline(yintercept = 2.5) +
  scale_color_manual(
    values = palette_IOFLOW,
    labels = c("reverse flow", "stasis", "first strike", "back flow"),
    name = "phase"
  ) +
  scale_fill_manual(values =  palette_IOFLOW) +
  theme_minimal()


plot.TrajectoryX_mean <- ggplot(data = Phase[[trial]],
                                aes(x = Timing[[trial]]$timing,
                                    y = average_tx)) +
  geom_point(aes(colour = as.factor(phase)), size = 1) +
  ylab("tx") +
  xlab("time") +
  scale_color_manual(
    values = palette_IOFLOW,
    labels = c("reverse flow", "stasis", "first strike", "back flow"),
    name = "phase"
  ) +
  scale_fill_manual(values =  palette_IOFLOW) +  
  theme_minimal() 


plot.Velocity_trend
plot.Velocity_mean
plot.TrajectoryX_mean

```


### Periodicity of the phases

To describe the suction feeding waterflow we compute the periodicity of the
different phases.

#### First strike
We extract the duration of the first strike

```{r}


First_strike_duration <-  map(.x = Trials, .f = ~length(which(phase[[.]]$phase == 1))) %>%
  set_names(names(Mean_vx_W_2))

# Mean and sd calculation for the first strike of each species
mean_FS_duration_Carp <- c(
  mean = mean(unlist(First_strike_duration)[Carp_names], na.rm = TRUE)/750,
    sd = sd(unlist(First_strike_duration)[Carp_names], na.rm = TRUE)/750)

mean_FS_duration_Tilapia <- c(
  mean = mean(unlist(First_strike_duration)[Tilapia_names], na.rm = TRUE)/750,
    sd = sd(unlist(First_strike_duration)[Tilapia_names], na.rm = TRUE)/750)

```

For the carp, the duration of the first strike was:
`r round(mean_FS_duration_Carp[1], digits = 2)` $\pm$
`r round(mean_FS_duration_Carp[2], digits = 2)` $s$  

For the tilapia, the duration of the first strike was:
`r round(mean_FS_duration_Tilapia[1], digits = 2)` $\pm$
`r round(mean_FS_duration_Tilapia[2], digits = 2)` $s$  

#### Periodicity of other phases

After the first strike, we export the peaks of tx over time

```{r}
# Detection of the transition between each reverse flow and back flow

peaks <-  map(.x = Trials,
              .f = ~ find_peaks(x = Phase[[.]]$average_tx, m = 150)) %>%
  set_names(names(Phase))


```

We want to extract the duration between each transition reverse/back flow:

```{r}

diff_peaks <- map(.x = Trials, 
                  .f = ~diff(peaks[[.]])) %>% set_names(names(Phase))

# Mean and sd calculation among the different transitions
mean_peaks <- map(.x = Trials, 
                  .f = ~mean(diff_peaks[[.]], na.rm = TRUE)) %>%
  set_names(names(Phase))

sd_peaks <-map(.x = Trials, .f = ~sd(diff_peaks[[.]], na.rm = TRUE)) %>% 
  set_names(names(Phase))

# Mean and sd calculation among the different trials of the same species
mean_peaks_Carp <- c(
  mean = mean(unlist(mean_peaks)[Carp_names], na.rm = TRUE)/750,
    sd = sd(unlist(mean_peaks)[Carp_names], na.rm = TRUE)/750)

mean_peaks_Tilapia <- c(
  mean = mean(unlist(mean_peaks)[Tilapia_names], na.rm = TRUE)/750,
    sd = sd(unlist(mean_peaks)[Tilapia_names], na.rm = TRUE)/750)

```

For the carp, the transition between a reverse and a backflow happens every 
`r round(mean_peaks_Carp[1], digits = 2)` $\pm$
`r round(mean_peaks_Carp[2], digits = 2)` $s$   
For the tilapia, the transition between a reverse and a backflow happens every
`r round(mean_peaks_Tilapia[1], digits = 2)` $\pm$ 
`r round(mean_peaks_Tilapia[2], digits = 2)` $s$


## Velocity amplitudes

To describe the waterflow over time, we need to compute several values, 
including maximum velocity amplitudes for the different phases in both carp 
and tilapia.


### Data preparation

We store in **Data_W_F** the mean and standard deviation of:     
- x, y, and z trajectories    
- x, y, and z velocities  
for all the food and water tracers over each trial.


```{r FirstStrike_magnitude, echo=TRUE, message=FALSE, warning=FALSE}

# List of the Water tracers variables
Data_W_F <- mapply(FUN = data.frame, Timing, phase,
         map(Trials,
             ~set_names(x=Mean_tx_W[[.]][2],nm = rep("average_TX", length(.)))),
         map(Trials,
             ~set_names(x=Mean_ty_W[[.]][2],nm = rep("average_TY", length(.)))),
         map(Trials,
             ~set_names(x=Mean_tz_W[[.]][2],nm = rep("average_TZ", length(.)))),
         map(Trials,
             ~set_names(x=Mean_tx_W[[.]][3],nm = rep("sd_TX", length(.)))),
         map(Trials,
             ~set_names(x=Mean_ty_W[[.]][3],nm = rep("sd_TY", length(.)))),
         map(Trials,
             ~set_names(x=Mean_tz_W[[.]][3],nm = rep("sd_TZ", length(.)))),
         
         map(Trials,
             ~set_names(x=Mean_tx_F[[.]][2],nm = rep("average_TX_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_ty_F[[.]][2],nm = rep("average_TY_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_tz_F[[.]][2],nm = rep("average_TZ_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_tx_F[[.]][3],nm = rep("sd_TX_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_ty_F[[.]][3],nm = rep("sd_TY_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_tz_F[[.]][3],nm = rep("sd_TZ_food", length(.)))),
         
         map(Trials, 
             ~set_names(x=Mean_vx_W[[.]][2],nm = rep("average_VX", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vy_W[[.]][2],nm = rep("average_VY", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vz_W[[.]][2],nm = rep("average_VZ", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vx_W[[.]][3],nm = rep("sd_VX", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vy_W[[.]][3],nm = rep("sd_VY", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vz_W[[.]][3],nm = rep("sd_VZ", length(.)))),
         
         map(Trials, 
             ~set_names(x=Mean_vx_F[[.]][2],nm = rep("average_VX_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vy_F[[.]][2],nm = rep("average_VY_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vz_F[[.]][2],nm = rep("average_VZ_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vx_F[[.]][3],nm = rep("sd_VX_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vy_F[[.]][3],nm = rep("sd_VY_food", length(.)))),
         map(Trials,
             ~set_names(x=Mean_vz_F[[.]][3],nm = rep("sd_VZ_food", length(.)))), SIMPLIFY = FALSE) %>%
  set_names(names(Timing))

```

### First strike

Then, we store:  
- initial value of the average_vX, at the beginning of the sequence   
- minimum of average_vX 
- maximum of average_vX 

to calculate:   
- anteroposterior velocity at the beginning of the sequence in a given species
for the water (W) and the food (F) 
- peak of anteroposterior velocity during the first strike in each 
- peak of anteroposterior velocity during the rest of the sequence in each 
species   


```{r}
# Compute the initial value of the average_vX, at the beginning of the sequence
Vx_FS_init_W <-  map_dbl(.x = Trials, 
                  .f = ~(Data_W_F[[.]]$average_VX[5]))
Vx_FS_init_F <-  map_dbl(.x = Trials, 
                  .f = ~(Data_W_F[[.]]$average_VX_food[5]))

# Compute the minimum of average_vX
Vx_FS_min_W <-  map_dbl(.x = Trials, 
                  .f = ~ (min(Data_W_F[[.]]$average_VX, na.rm = TRUE)))
Vx_FS_min_F <-  map_dbl(.x = Trials, 
                  .f = ~ (min(Data_W_F[[.]]$average_VX_food, na.rm = TRUE)))


# Compute the maximum of average_vX 
Vx_FS_max_W <-  map_dbl(.x = Trials, 
                  .f = ~ (max(Data_W_F[[.]]$average_VX, na.rm = TRUE)))

Vx_FS_max_F <-  map_dbl(.x = Trials, 
                  .f = ~ (max(Data_W_F[[.]]$average_VX_food, na.rm = TRUE)))


# Compute the anteroposterior velocity at the beginning of the 
#sequence for each species and each item (W and F):

## carp
Vx_FS_init_Carp_mean_W <- mean(Vx_FS_init_W[1:7])
Vx_FS_init_Carp_sd_W <- sd(Vx_FS_init_W[1:7])

Vx_FS_init_Carp_mean_F <- mean(Vx_FS_init_F[1:7])
Vx_FS_init_Carp_sd_F <- sd(Vx_FS_init_F[1:7])


## tilapia
Vx_FS_init_Tilapia_mean_W <- mean(Vx_FS_init_W[8:13])
Vx_FS_init_Tilapia_sd_W<- sd(Vx_FS_init_W[8:13])

Vx_FS_init_Tilapia_mean_F <- mean(Vx_FS_init_F[8:13])
Vx_FS_init_Tilapia_sd_F<- sd(Vx_FS_init_F[8:13])

# Compute the peak of anteroposterior velocity during the first strike in each 
# species :

## carp
Vx_FS_min_Carp_mean_W <- mean(Vx_FS_min_W[1:7])
Vx_FS_min_Carp_sd_W <- sd(Vx_FS_min_W[1:7])

Vx_FS_min_Carp_mean_F <- mean(Vx_FS_min_F[1:7])
Vx_FS_min_Carp_sd_F <- sd(Vx_FS_min_F[1:7])


## tilapia
Vx_FS_min_Tilapia_mean_W <- mean(Vx_FS_min_W[8:13])
Vx_FS_min_Tilapia_sd_W<- sd(Vx_FS_min_W[8:13])

Vx_FS_min_Tilapia_mean_F <- mean(Vx_FS_min_F[8:13])
Vx_FS_min_Tilapia_sd_F<- sd(Vx_FS_min_F[8:13])

# Compute the peak of anteroposterior velocity during the rest of the sequence 
#in each species :

## carp
Vx_FS_max_Carp_mean_W <- mean(Vx_FS_max_W[1:7])
Vx_FS_max_Carp_sd_W <- sd(Vx_FS_max_W[1:7])

Vx_FS_max_Carp_mean_F <- mean(Vx_FS_max_F[1:7])
Vx_FS_max_Carp_sd_F <- sd(Vx_FS_max_F[1:7])

## tilapia
Vx_FS_max_Tilapia_mean_W <- mean(Vx_FS_max_W[8:13])
Vx_FS_max_Tilapia_sd_W<- sd(Vx_FS_max_W[8:13])

Vx_FS_max_Tilapia_mean_F <- mean(Vx_FS_max_F[8:13])
Vx_FS_max_Tilapia_sd_F<- sd(Vx_FS_max_F[8:13])

```

The absolute anteroposterior velocity of the water tracers increased from 
`r round(abs(Vx_FS_init_Carp_mean_W), digits = 2) ` $\pm$ 
`r round(Vx_FS_init_Carp_sd_W, digits=2) ` $cm/s$ to up to 
`r round(abs(Vx_FS_min_Carp_mean_W), digits = 2) ` $\pm$ 
`r round(Vx_FS_min_Carp_sd_W, digits=2) ` $cm/s$ for the carp (Fig. 2a), and from 

`r round(abs(Vx_FS_init_Tilapia_mean_W), digits = 2) ` $\pm$ 
`r round(Vx_FS_init_Tilapia_sd_W, digits=2) ` $cm/s$ to up to 
`r round(abs(Vx_FS_min_Tilapia_mean_W), digits = 2) ` $\pm$ 
`r round(Vx_FS_min_Tilapia_sd_W, digits=2) ` $cm/s$
for the tilapia’s (Fig. 2b). 

This magnitude was never reached again (maximum during food capture of
`r round(abs(Vx_FS_max_Carp_mean_W), digits = 2) ` $\pm$ 
`r round(Vx_FS_max_Carp_sd_W, digits=2) ` $cm/s$ 
in carp and 
`r round(abs(Vx_FS_max_Tilapia_mean_W), digits = 2) ` $\pm$ 
`r round(Vx_FS_max_Tilapia_sd_W, digits=2) ` $cm/s$ 
in tilapia). 
After the first strike, a phase of apparent stasis occurred, with a steady, low-velocity, anteroposterior trajectory of the water tracers, leading to a nearly complete stop of the food. 


### Reverse flow 

We use the maximum of the **average_VX** data to obtain the maximum amplitude
the water tracers motion during the reverse flow because the X axis is pointing
toward the back of the buccal cavity.

```{r ReverseFlow_magnitude, echo=TRUE, message=FALSE, warning=FALSE}

# Compute the min of the average_X
Vx_RF <-  map_dbl(.x = Trials, 
                  .f = ~ abs(max(Data_W_F[[.]]$average_VX, na.rm = TRUE)))

ReverseFlow_magnitude <-  data.frame(Trial = names(Maya_WF),
                                     ReverseFlow_magnitude = Vx_RF)

ReverseFlow_magnitude %>%
  kable() %>%
  kable_styling()

# Compute the mean among a given species

## carp
Vx_RF_Carp <- abs(Vx_RF[1:7])

## tilapia
Vx_RF_Tilapia <- abs(Vx_RF[8:13])

```

- For the carp, the maximum velocity amplitude is
`r round(mean(Vx_RF_Carp), digits = 2) ` $\pm$   
`r round(x=sd(Vx_RF_Carp), digits=2) ` $cm/s$  

- For the tilapia, the maximum velocity amplitude is 
`r round(mean(Vx_RF_Tilapia), digits = 2) ` $\pm$ 
`r round(x=sd(Vx_RF_Tilapia), digits=2) ` $cm/s$
  
  
## Relative proportion of tx, ty, tz 

We want to calculate the relative contribution of each component of the 
trajectory. 

### Data preparation

We compute the proportion of tx, ty, and tz over each sequence and for each 
item.

```{r Data_Proportion , echo=TRUE, message=FALSE, warning=FALSE}

Data_Proportion <-  map(.x = Trials,
                        .f = ~ mutate(
                          .data = Data_W_F[[.]],
                          tr = abs(Data_W_F[[.]]$average_TX) +
                            abs(Data_W_F[[.]]$average_TY) +
                            abs(Data_W_F[[.]]$average_TZ)))

Data_Proportion <-  map(.x = Trials,
                        .f = ~ mutate(
                          .data = Data_Proportion[[.]],
                          tr_food = abs(Data_W_F[[.]]$average_TX_food) +
                            abs(Data_W_F[[.]]$average_TY_food) +
                            abs(Data_W_F[[.]]$average_TZ_food)))

Data_Proportion <-  map(.x = Trials,  
                        .f = ~ mutate(
                          .data = Data_Proportion[[.]],
                          tx_prop = abs(Data_Proportion[[.]]$average_TX) /
                            Data_Proportion[[.]]$tr,
                          ty_prop = abs(Data_Proportion[[.]]$average_TY) /
                            Data_Proportion[[.]]$tr,
                          tz_prop = abs(Data_Proportion[[.]]$average_TZ) /
                            Data_Proportion[[.]]$tr ,
                          tx_prop_food = abs(Data_Proportion[[.]]$average_TX_food) /
                            Data_Proportion[[.]]$tr_food,
                          ty_prop_food = abs(Data_Proportion[[.]]$average_TY_food) /
                            Data_Proportion[[.]]$tr_food,
                          tz_prop_food = abs(Data_Proportion[[.]]$average_TZ_food) /
                            Data_Proportion[[.]]$tr_food
                          )                    
                        ) %>%
  set_names(names(Sum_dist_WF))

```


### First strike

We extract the first strike data, based on the "phase" variable. 

```{r FirstStrike_comp}

# reminder
#  1: first strike
#  0: stasis
# -1: reverse flow
#  2: back flow

FirstStrike_comp <- map(.x = Trials,
  .f = ~ Data_Proportion[[.]][which(Data_Proportion[[.]]$phase == 1), ]) %>%
  set_names(names(Data_Proportion))

```

We calculate the mean and standard deviation of each component proportion for
the food tracers. 

```{r}
# Food 

Mean_FirstStrike_comp_F <-
  map(.x = Trials,
      .f = ~ FirstStrike_comp[[.]] %>%
        summarise(
          mean_tx_prop = mean(tx_prop_food, na.rm = TRUE),
          mean_ty_prop = mean(ty_prop_food, na.rm = TRUE),
          mean_tz_prop = mean(tz_prop_food, na.rm = TRUE),
          sd_tx_prop =  sd(tx_prop_food, na.rm = TRUE),
          sd_ty_prop =  sd(ty_prop_food, na.rm = TRUE),
          sd_tz_prop =  sd(tz_prop_food, na.rm = TRUE))) %>%
  set_names(names(FirstStrike_comp))

Mean_FirstStrike_comp__F <- data.frame(
  mean = c(
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp_F[[.]]$mean_tx_prop
    ),
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp_F[[.]]$mean_ty_prop
    ),
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp_F[[.]]$mean_tz_prop
    )
  ),
  sd = c(
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp_F[[.]]$sd_tx_prop
    ),
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp_F[[.]]$sd_ty_prop
    ),
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp_F[[.]]$sd_tz_prop
    )
  ),
  species = c(rep("carp", 7), rep("tilapia", 6)),
  trials = names(Mean_FirstStrike_comp_F),
  component = c(rep("tx", length(Trials)),
                rep("ty", length(Trials)),
                rep("tz", length(Trials)))
)

```

We calculate the mean and standard deviation of each component proportion for
the water tracers. 

```{r}
# Water

Mean_FirstStrike_comp <-
  map(.x = Trials,
      .f = ~ FirstStrike_comp[[.]] %>%
        summarise(
          mean_tx_prop = mean(tx_prop, na.rm = TRUE),
          mean_ty_prop = mean(ty_prop, na.rm = TRUE),
          mean_tz_prop = mean(tz_prop, na.rm = TRUE),
          sd_tx_prop =  sd(tx_prop, na.rm = TRUE),
          sd_ty_prop =  sd(ty_prop, na.rm = TRUE),
          sd_tz_prop =  sd(tz_prop, na.rm = TRUE))) %>%
  set_names(names(FirstStrike_comp))

Mean_FirstStrike_comp__ <- data.frame(
  mean = c(
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp[[.]]$mean_tx_prop
    ),
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp[[.]]$mean_ty_prop
    ),
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp[[.]]$mean_tz_prop
    )
  ),
  sd = c(
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp[[.]]$sd_tx_prop
    ),
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp[[.]]$sd_ty_prop
    ),
    map_dbl(
      .x = Trials,
      .f = ~ Mean_FirstStrike_comp[[.]]$sd_tz_prop
    )
  ),
  species = c(rep("carp", 7), rep("tilapia", 6)),
  trials = names(Mean_FirstStrike_comp),
  component = c(rep("tx", length(Trials)),
                rep("ty", length(Trials)),
                rep("tz", length(Trials)))
)
```

Based on these data, we plot an histogram corresponding to the x, y, and z 
components contribution for the first strike among the 13 analyzed trials 
for each item (water and food). 

```{r, echo=TRUE, message=FALSE, warning=FALSE, fig.width=7, fig.show='hold',fig.align='center'}
# plot the First strike data for each trial
ggplot(data = Mean_FirstStrike_comp__F, 
       aes(x = trials, 
           y = mean, 
           fill =component)) +
  geom_bar(stat = "identity", 
           position = position_dodge()) +
  geom_errorbar(aes(ymin = mean - sd, 
                    ymax = mean + sd),
                width = .2,
                position = position_dodge(0.9)) +
  theme_minimal() +
  # theme(legend.position = "none") +
  guides(x =  guide_axis(angle = 45)) +
  labs(subtitle = "First strike food tracers")

ggplot(data = Mean_FirstStrike_comp__, 
       aes(x = trials, 
           y = mean, 
           fill =component)) +
  geom_bar(stat = "identity", 
           position = position_dodge()) +
  geom_errorbar(aes(ymin = mean - sd, 
                    ymax = mean + sd),
                width = .2,
                position = position_dodge(0.9)) +
  theme_minimal() +
  # theme(legend.position = "none") +
  guides(x =  guide_axis(angle = 45)) +
  labs(subtitle = "First strike water tracers")


```


### Reverse flow

We extract the reverse flow data, based on the "phase" variable and plot the 
relative contribution of each variable during the reverse flow phase

```{r RF_component}

# reminder
#  1: first strike
#  0: stasis
# -1: reverse flow
#  2: back flow

RF_comp <-
  map(.x = Trials,
      ~ Data_Proportion[[.]][which(Data_Proportion[[.]]$phase == -1), ])  %>%
  set_names(names(Data_Proportion))

```

We calculate the mean and standard deviation of each component proportion for
the food tracers. 

```{r}
# food

Mean_RF_comp_F <- map(
  .x = Trials,
  .f = ~ RF_comp[[.]] %>%
    summarise(
      mean_tx_prop_food = mean(tx_prop_food, na.rm = TRUE),
      mean_ty_prop_food = mean(ty_prop_food, na.rm = TRUE),
      mean_tz_prop_food = mean(tz_prop_food, na.rm = TRUE),
      sd_tx_prop_food =  sd(tx_prop_food, na.rm = TRUE),
      sd_ty_prop_food =  sd(ty_prop_food, na.rm = TRUE),
      sd_tz_prop_food =  sd(tz_prop_food, na.rm = TRUE)
    )
) %>%
  set_names(names(RF_comp))


Mean_RF_comp__F <- data.frame(
  mean = c(
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp_F[[.]]$mean_tx_prop_food),
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp_F[[.]]$mean_ty_prop_food),
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp_F[[.]]$mean_tz_prop_food)
  ),
  sd = c(
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp_F[[.]]$sd_tx_prop_food),
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp_F[[.]]$sd_ty_prop_food),
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp_F[[.]]$sd_tz_prop_food)
  ),
  species = c(rep("carp", 7), rep("tilapia", 6)),
  trials = names(Mean_RF_comp_F),
  component = c(rep("tx", length(Trials)),
                rep("ty", length(Trials)),
                rep("tz", length(Trials)))
)

```

We calculate the mean and standard deviation of each component proportion for
the water tracers. 

```{r}

# water
Mean_RF_comp <- map(
  .x = Trials,
  .f = ~ RF_comp[[.]] %>%
    summarise(
      mean_tx_prop = mean(tx_prop, na.rm = TRUE),
      mean_ty_prop = mean(ty_prop, na.rm = TRUE),
      mean_tz_prop = mean(tz_prop, na.rm = TRUE),
      sd_tx_prop =  sd(tx_prop, na.rm = TRUE),
      sd_ty_prop =  sd(ty_prop, na.rm = TRUE),
      sd_tz_prop =  sd(tz_prop, na.rm = TRUE)
    )
) %>%
  set_names(names(RF_comp))


Mean_RF_comp__ <- data.frame(
  mean = c(
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp[[.]]$mean_tx_prop),
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp[[.]]$mean_ty_prop),
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp[[.]]$mean_tz_prop)
  ),
  sd = c(
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp[[.]]$sd_tx_prop),
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp[[.]]$sd_ty_prop),
    map_dbl(.x = Trials, .f = ~ Mean_RF_comp[[.]]$sd_tz_prop)
  ),
  species = c(rep("carp", 7), rep("tilapia", 6)),
  trials = names(Mean_RF_comp),
  component = c(rep("tx", length(Trials)),
                rep("ty", length(Trials)),
                rep("tz", length(Trials)))
)
```


Based on these data, we plot an histogram corresponding to the x, y, and z 
components contribution for the reverse flow among the 13 analyzed trials 
for each item (water and food). 

```{r , echo=TRUE, message=FALSE, warning=FALSE, fig.width=7, fig.show='hold',fig.align='center'}
# plot the RF data for each trial
# food
ggplot(data = Mean_RF_comp__F, aes(x = trials, y = mean, fill = component)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = .2,
                position = position_dodge(0.9)) +
  theme_minimal() +
  # theme(legend.position = "none") +
  guides(x =  guide_axis(angle = 45)) +
  labs(subtitle = "Reverse flow food tracers")


# water
ggplot(data = Mean_RF_comp__, aes(x = trials, y = mean, fill = component)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = .2,
                position = position_dodge(0.9)) +
  theme_minimal() +
  # theme(legend.position = "none") +
  guides(x =  guide_axis(angle = 45)) +
  labs(subtitle = "Reverse flow water tracers")

```




### Back Flow

We extract the back flow data, based on the "phase" variable and plot the 
relative contribution of each variable during the back flow phase.

```{r BF_component}

# reminder
#  1: first strike
#  0: stasis
# -1: reverse flow
#  2: back flow

BF_comp <-
  map(.x = Trials,
      ~ Data_Proportion[[.]][which(Data_Proportion[[.]]$phase == 2), ])  %>%
  set_names(names(Data_Proportion))
```

We calculate the mean and standard deviation of each component proportion for
the food tracers.

```{r}

# food
Mean_BF_comp_F <- map(
  .x = Trials,
  .f = ~ BF_comp[[.]] %>%
    summarise(
      mean_tx_prop_food = mean(tx_prop_food, na.rm = TRUE),
      mean_ty_prop_food = mean(ty_prop_food, na.rm = TRUE),
      mean_tz_prop_food = mean(tz_prop_food, na.rm = TRUE),
      sd_tx_prop_food =  sd(tx_prop_food, na.rm = TRUE),
      sd_ty_prop_food =  sd(ty_prop_food, na.rm = TRUE),
      sd_tz_prop_food =  sd(tz_prop_food, na.rm = TRUE)
    )
) %>%
  set_names(names(BF_comp))


Mean_BF_comp__F <- data.frame(
  mean = c(
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp_F[[.]]$mean_tx_prop_food),
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp_F[[.]]$mean_ty_prop_food),
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp_F[[.]]$mean_tz_prop_food)
  ),
  sd = c(
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp_F[[.]]$sd_tx_prop_food),
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp_F[[.]]$sd_ty_prop_food),
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp_F[[.]]$sd_tz_prop_food)
  ),
  species = c(rep("carp", 7), rep("tilapia", 6)),
  trials = names(Mean_BF_comp_F),
  component = c(rep("tx", length(Trials)),
                rep("ty", length(Trials)),
                rep("tz", length(Trials)))
)
```

We calculate the mean and standard deviation of each component proportion for
the water tracers.

```{r}
# water
Mean_BF_comp <- map(
  .x = Trials,
  .f = ~ BF_comp[[.]] %>%
    summarise(
      mean_tx_prop = mean(tx_prop, na.rm = TRUE),
      mean_ty_prop = mean(ty_prop, na.rm = TRUE),
      mean_tz_prop = mean(tz_prop, na.rm = TRUE),
      sd_tx_prop =  sd(tx_prop, na.rm = TRUE),
      sd_ty_prop =  sd(ty_prop, na.rm = TRUE),
      sd_tz_prop =  sd(tz_prop, na.rm = TRUE)
    )
) %>%
  set_names(names(BF_comp))


Mean_BF_comp__ <- data.frame(
  mean = c(
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp[[.]]$mean_tx_prop),
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp[[.]]$mean_ty_prop),
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp[[.]]$mean_tz_prop)
  ),
  sd = c(
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp[[.]]$sd_tx_prop),
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp[[.]]$sd_ty_prop),
    map_dbl(.x = Trials, .f = ~ Mean_BF_comp[[.]]$sd_tz_prop)
  ),
  species = c(rep("carp", 7), rep("tilapia", 6)),
  trials = names(Mean_BF_comp),
  component = c(rep("tx", length(Trials)),
                rep("ty", length(Trials)),
                rep("tz", length(Trials)))
)

```

Based on these data, we plot an histogram corresponding to the x, y, and z 
components contribution for the back flow among the 13 analyzed trials 
for each item (water and food). 

```{r , echo=TRUE, message=FALSE, warning=FALSE, fig.width=7, fig.show='hold',fig.align='center'}
# plot the Back flow data for each trial
# food
ggplot(data = Mean_BF_comp__F, aes(x = trials, y = mean, fill = component)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = .2,
                position = position_dodge(0.9)) +
  theme_minimal() +
  # theme(legend.position = "none") +
  guides(x =  guide_axis(angle = 45)) +
  labs(subtitle = "Back flow food tracers")



# water
ggplot(data = Mean_BF_comp__, aes(x = trials, y = mean, fill = component)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd),
                width = .2,
                position = position_dodge(0.9)) +
  theme_minimal() +
  # theme(legend.position = "none") +
  guides(x =  guide_axis(angle = 45)) +
  labs(subtitle = "Back flow water tracers")

```



## Mean Relative proportion of each component during each phase

We average the previous data on all the trials of a given species.
The data correspond to Table S1 in the manuscript.

### First strike

#### Food tracer


```{r FirstStrike_comp_mean , echo=TRUE, message=FALSE, warning=FALSE}

comp <- c("tx", "ty", "tz")
color_components <-
  c(palette_IOFLOW[4], palette_IOFLOW[7], palette_IOFLOW[5])

# Food 

Mean_FirstStrike_comp_F <-
  data.frame(
mean = c(map_dbl(
   .x = comp,
   .f = ~ mean(Mean_FirstStrike_comp__F[Mean_FirstStrike_comp__F$component ==. &
                                            Mean_FirstStrike_comp__F$species == 
                                         "carp" , ]$mean, na.rm = TRUE)),
    map_dbl(
    .x = comp,
    .f = ~ mean(Mean_FirstStrike_comp__F[Mean_FirstStrike_comp__F$component ==. &
                                              Mean_FirstStrike_comp__F$species ==
                                           "tilapia", ]$mean, na.rm = TRUE))),
    sd = c(map_dbl(
      .x = comp,
      .f = ~ sd(Mean_FirstStrike_comp__F[Mean_FirstStrike_comp__F$component ==. &
                                          Mean_FirstStrike_comp__F$species == 
                                          "carp" , ]$mean)),
    
    map_dbl(
      .x = comp,
      .f = ~ sd(Mean_FirstStrike_comp__F[Mean_FirstStrike_comp__F$component ==. &
                                        Mean_FirstStrike_comp__F$species ==
                                          "tilapia" , ]$mean, na.rm = TRUE))),
    species = c(rep("carp", 3), rep("tilapia", 3)),
    component = rep(c("tx", "ty", "tz"), 2))

# Visualisation of the data

hist_FS_F <-
  ggplot(data = Mean_FirstStrike_comp_F, 
         aes(x = component, 
             y = mean * 100,
             fill =  component)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(
    aes(ymin = mean * 100 - sd * 100, 
        ymax = mean * 100 + sd * 100),
    width = .2,
    position = position_dodge(0.9)
  ) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("Component contribution") +
  xlab("Relative proportion of each component ") +
  facet_wrap( ~ species, scales = "free") +
  scale_color_manual(values = color_components) +
  scale_fill_manual(values =  color_components) +
    labs(title = "" , subtitle = "a. First strike Food tracer")


```

#### Water tracers

```{r}

# water
Mean_first_strike_Comp <-
  data.frame(
mean = c(map_dbl(
   .x = comp,
   .f = ~ mean(Mean_FirstStrike_comp__[Mean_FirstStrike_comp__$component ==. &
                                            Mean_FirstStrike_comp__$species == 
                                         "carp" , ]$mean, na.rm = TRUE)),
    map_dbl(
    .x = comp,
    .f = ~ mean(Mean_FirstStrike_comp__[Mean_FirstStrike_comp__$component ==. &
                                              Mean_FirstStrike_comp__$species ==
                                           "tilapia", ]$mean, na.rm = TRUE))),
    sd = c(map_dbl(
      .x = comp,
      .f = ~ sd(Mean_FirstStrike_comp__[Mean_FirstStrike_comp__$component ==. &
                                          Mean_FirstStrike_comp__$species == 
                                          "carp" , ]$mean)),
    
    map_dbl(
      .x = comp,
      .f = ~ sd(Mean_FirstStrike_comp__[Mean_FirstStrike_comp__$component ==. &
                                        Mean_FirstStrike_comp__$species ==
                                          "tilapia" , ]$mean, na.rm = TRUE))),
    species = c(rep("carp", 3), rep("tilapia", 3)),
    component = rep(c("tx", "ty", "tz"), 2))

# Visualisation of the data
hist_FS <-
  ggplot(data = Mean_first_strike_Comp, 
         aes(x = component, 
             y = mean * 100,
             fill =  component)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(
    aes(ymin = mean * 100 - sd * 100, 
        ymax = mean * 100 + sd * 100),
    width = .2,
    position = position_dodge(0.9)
  ) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("Component contribution") +
  xlab("Relative proportion of each component ") +
  facet_wrap( ~ species, scales = "free") +
  scale_color_manual(values = color_components) +
  scale_fill_manual(values =  color_components) +
  labs(title = "" , subtitle = "b. First strike Water tracers")

```



### Reverse Flow

#### Food tracer

```{r RF_comp_mean , echo=TRUE, message=FALSE, warning=FALSE}
# Food

Mean_RF_comp_F <-  data.frame(
  mean = c(map_dbl(
    .x = comp,
    .f = ~ mean(Mean_RF_comp__F[Mean_RF_comp__F$component == . &
                                 Mean_RF_comp__F$species == "carp" ,]$mean, 
                na.rm = TRUE)
  ),
  map_dbl(
    .x = comp,
    .f = ~ mean(Mean_RF_comp__F[Mean_RF_comp__F$component == . &
                                 Mean_RF_comp__F$species == "tilapia" ,]$mean, 
                na.rm = TRUE)
  )),
  sd = c(map_dbl(
    .x = comp,
    .f = ~ sd(Mean_RF_comp__F[Mean_RF_comp__F$component ==
                               . &
                               Mean_RF_comp__F$species == "carp" ,]$mean)
  ),
  map_dbl(
    .x = comp,
    .f = ~ sd(Mean_RF_comp__F[Mean_RF_comp__F$component == . &
                               Mean_RF_comp__F$species == "tilapia" ,]$mean, 
              na.rm = TRUE)
  )),
  species = c(rep("carp", 3), rep("tilapia", 3)),
  component = rep(c("tx", "ty", "tz"), 2)
)


# Visualisation of the data
hist_RF_F <-
  ggplot(data = Mean_RF_comp_F, aes(x = component, 
                                  y = mean * 100,
                                  fill = component)) +
  geom_bar(stat = "identity", 
           position = position_dodge()) +
  geom_errorbar(
    aes(ymin = mean * 100 - sd * 100, ymax = mean * 100 + sd * 100),
    width = .2,
    position = position_dodge(0.9)) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("Component contribution") +
  xlab("") +
  facet_wrap( ~ species, scales = "free") +
  scale_color_manual(values = color_components) +
  scale_fill_manual(values =  color_components) +
  labs(subtitle = "c. Reverse Flow Food tracers")

```

```{r}
# Water
Mean_RF_Comp <-  data.frame(
  mean = c(map_dbl(
    .x = comp,
    .f = ~ mean(Mean_RF_comp__[Mean_RF_comp__$component == . &
                                 Mean_RF_comp__$species == "carp" ,]$mean, 
                na.rm = TRUE)
  ),
  map_dbl(
    .x = comp,
    .f = ~ mean(Mean_RF_comp__[Mean_RF_comp__$component == . &
                                 Mean_RF_comp__$species == "tilapia" ,]$mean, 
                na.rm = TRUE)
  )),
  sd = c(map_dbl(
    .x = comp,
    .f = ~ sd(Mean_RF_comp__[Mean_RF_comp__$component ==
                               . &
                               Mean_RF_comp__$species == "carp" ,]$mean)
  ),
  map_dbl(
    .x = comp,
    .f = ~ sd(Mean_RF_comp__[Mean_RF_comp__$component == . &
                               Mean_RF_comp__$species == "tilapia" ,]$mean, 
              na.rm = TRUE)
  )),
  species = c(rep("carp", 3), rep("tilapia", 3)),
  component = rep(c("tx", "ty", "tz"), 2)
)

# Visualisation of the data

hist_RF <-
  ggplot(data = Mean_RF_Comp, aes(x = component, 
                                  y = mean * 100,
                                  fill = component)) +
  geom_bar(stat = "identity", 
           position = position_dodge()) +
  geom_errorbar(
    aes(ymin = mean * 100 - sd * 100, ymax = mean * 100 + sd * 100),
    width = .2,
    position = position_dodge(0.9)) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("Component contribution") +
  xlab("") +
  facet_wrap( ~ species, scales = "free") +
  scale_color_manual(values = color_components) +
  scale_fill_manual(values =  color_components) +
  labs(subtitle = "d. Reverse Flow water tracers")

```


### Back flow

#### Food

```{r BF_comp_mean , echo=TRUE, message=FALSE, warning=FALSE, fig.width=5, fig.show='hold',fig.align='center'}

# Food
Mean_BF_Comp_F <-
  data.frame(
    mean = c(map_dbl(
      .x = comp,
      .f = ~ mean(Mean_BF_comp__F[Mean_BF_comp__F$component == . &
                                   Mean_BF_comp__F$species == "carp", ]$mean,
                  na.rm = TRUE)
    ), map_dbl(
      .x = comp,
      .f = ~ mean(Mean_BF_comp__F[Mean_BF_comp__F$component == . &
                                   Mean_BF_comp__F$species == "tilapia", ]$mean, 
                  na.rm = TRUE)
    )),
    sd = c(map_dbl(
      .x = comp,
      .f = ~ sd(Mean_BF_comp__F[Mean_BF_comp__F$component == . &
                                 Mean_BF_comp__F$species == "carp" , ]$mean, 
                na.rm = TRUE)
    ), map_dbl(
      .x = comp,
      .f = ~ sd(Mean_BF_comp__F[Mean_BF_comp__F$component == . &
                                 Mean_BF_comp__F$species == "tilapia" , 
                               ]$mean, na.rm = TRUE)
    )),
    species = c(rep("carp", 3), rep("tilapia", 3)),
    component = rep(c("tx", "ty", "tz"), 2)
  )

# Visualisation of the data
hist_BF_F <-
  ggplot(data = Mean_BF_Comp_F, 
         aes(x = component, y = mean * 100, fill = component)) +
  geom_bar(stat = "identity", 
           position = position_dodge()) +
  geom_errorbar(
    aes(ymin = mean * 100 - sd * 100, 
        ymax = mean * 100 + sd * 100),
    width = .2,
    position = position_dodge(0.9)) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("Component contribution") +
  xlab("") +
  facet_wrap( ~ species, scales = "free") +
  scale_color_manual(values = color_components) +
  scale_fill_manual(values =  color_components) +
  labs(subtitle = "e. Back Flow Food tracers")
```

```{r , echo=TRUE, message=FALSE, warning=FALSE, fig.width=7, fig.show='hold',fig.align='center'}
# Water
Mean_BF_Comp <-
  data.frame(
    mean = c(map_dbl(
      .x = comp,
      .f = ~ mean(Mean_BF_comp__[Mean_BF_comp__$component == . &
                                   Mean_BF_comp__$species == "carp", ]$mean,
                  na.rm = TRUE)
    ), map_dbl(
      .x = comp,
      .f = ~ mean(Mean_BF_comp__[Mean_BF_comp__$component == . &
                                   Mean_BF_comp__$species == "tilapia", ]$mean, 
                  na.rm = TRUE)
    )),
    sd = c(map_dbl(
      .x = comp,
      .f = ~ sd(Mean_BF_comp__[Mean_BF_comp__$component == . &
                                 Mean_BF_comp__$species == "carp" , ]$mean, 
                na.rm = TRUE)
    ), map_dbl(
      .x = comp,
      .f = ~ sd(Mean_BF_comp__[Mean_BF_comp__$component == . &
                                 Mean_BF_comp__$species == "tilapia" , 
                               ]$mean, na.rm = TRUE)
    )),
    species = c(rep("carp", 3), rep("tilapia", 3)),
    component = rep(c("tx", "ty", "tz"), 2)
  )

# Visualisation of the data
hist_BF <-
  ggplot(data = Mean_BF_Comp, 
         aes(x = component, y = mean * 100, fill = component)) +
  geom_bar(stat = "identity", 
           position = position_dodge()) +
  geom_errorbar(
    aes(ymin = mean * 100 - sd * 100, 
        ymax = mean * 100 + sd * 100),
    width = .2,
    position = position_dodge(0.9)) +
  theme_minimal() +
  theme(legend.position = "none") +
  ylab("Component contribution") +
  xlab("") +
  facet_wrap( ~ species, scales = "free") +
  scale_color_manual(values = color_components) +
  scale_fill_manual(values =  color_components) +
  labs(subtitle = "f. Back Flow water Tracers")

hist_FS_F
hist_FS
hist_RF_F
hist_RF
hist_BF_F
hist_BF

```

During each phase, the anterio posterior component is the most important one. 
The vertical component is more important for the tilapia compared with
the carp, especially during the reverse and back flows.    


## Divergence 

We hypothesize that the waterflow, exiting through the opercula during each 
backflow, causes a passive sorting based on the different mass of the ingested
particles. The inertia effect would lead the biggest particles (food item) to
stay on the same path, following a midsagittal trajectory towards the esophagus.
The cycles reverse flow / back flow put the tracers in suspension in the buccal
cavity and increase the probability to be sensed with appropriate sensory organs
and trapped (actively) by the pharyngeal jaws if they correspond to a food item. 

We explored this hypothesis by detecting the shift in the waterflow trajectory 
in comparison to the food tracer trajectory by calculating the curvature formed 
by the position of a given particle during three consecutive frame.  


### Data preparation

We store all the tx, ty, and tz for all the particles of the first strike of
each trial in a list.

```{r}

Trajectory <- map(.x = Trials, .f = ~Map(as.data.frame(cbind), 
                                    WF_tx = WF_tx [[.]][],
                                    WF_ty = WF_ty [[.]][],
                                    WF_tz = WF_tz [[.]][],     
                                    Time = Phase[[.]][11]/750,
                                    Frame = Phase[[.]][11],
                                    Phase = Phase[[.]][14])) %>% 
  set_names(names(Maya_WF))


Trajectory_df <- list_to_df(list = Trajectory, id.vars = c(
"value.WF_tx",
"value.WF_ty",
"value.WF_tz",
"value.Time",
"value.Frame",
"value.Phase"), 
           replace_by = c("value.", ""), 
           replace_L1 = "Trials", 
           replace_L2 = "Particles")

# we add an item column
Trajectory_df <- Trajectory_df %>% mutate(item = case_when(
str_detect(Trajectory_df$Particles, "F") ~ "W",
str_detect(Trajectory_df$Particles, "A") ~ "F")) 
  
# create a vector with the name of each specimen
Specimens <- levels(factor(substr(names(Maya_WF), start = 1, stop = 2)))

# list all the trials associated with one specimen 
Trial_Specimens <- map(.x = Specimens,
                       .f =~levels(factor(Trajectory_df$Trials))[
                         which(substr(levels(factor(Trajectory_df$Trials)), 
                                      start = 1, stop = 2) == .)]
                         ) %>%  set_names(Specimens)

# create a df with the data for the First Strike

FS <-  Trajectory_df  %>%  filter(Phase == "1") %>% 
  mutate(Grp = paste(Particles,Trials, sep="_"))

FS_Specimen <- map(.x = c(1:4), 
                   .f = ~subset(FS, 
                                subset= is.element(Trials,
                                                   Trial_Specimens[[.]]))) %>% set_names(Specimens)

FS_Trial <- map(.x = Trials, 
                .f = ~filter(FS, Trials == names(Maya_WF)[.])) %>% set_names(names(Maya_WF))

           
```

#### Trajectory cleaning

We want to filter and clean the data to only have the First Strike and 
clean the trajectory of the particles that circle back towards the entrance of 
the mouth.
We also add a calculation of the percentage of the anteroposterior position  
- 0% corresponds to the entrance of the mouth  
- 100% corresponds to the entrance of the esophagus.  

```{r}

# cutting before the particles are in the buccal cavity:

FS_Trial_clean_beginning <- map(.x = Trials, 
                                .f = ~delete_beginning(FS_Trial[[.]], .) )



# cutting the particles that circle back towards the entrance of the mouth

FS_Trial_clean_curling <- map(.x = Trials , 
    .f = ~ delete_curling(data = FS_Trial_clean_beginning[[.]], Particles = levels(factor(FS_Trial_clean_beginning[[.]]$Grp)), trial = .)) %>% set_names(names(Maya_WF)[Trials])


# Adding a column with the percentage of tx: tx_pcent

FS_Trial_clean <- map(.x = Trials, 
                      .f = ~ mutate(.data = FS_Trial_clean_curling[[.]],
                        WF_tx_pcent = 100 -
                          FS_Trial_clean_curling[[.]]$WF_tx/
                          (max(FS_Trial_clean_curling[[.]]$WF_tx, na.rm=TRUE))*100 
                        )) %>%
  set_names(names(Maya_WF)[Trials])
                  

```

Now we can compare the initial position and the position at the end of the first intake


Now we can compute the divergence in trajectory between the water tracers and
the food tracers. 
We calculate the curvature made by the trajectory of each particle in the
medio-lateral angle.


### Calculation

#### Mediolateral motions

We calculate the angle and curvature created by a given particle over 3 
consecutive frames in the dorsoventral plane, to obtain the divergence caused by
the mediolateral motions. We use compute_divergence function to calculate the
angle and the curvature.

```{r}
Divergence <- list()
span <- 1 # for each frame

for(trial in Trials){ # c(1:10,12:13)
  Particles <- levels(factor(FS_Trial_clean[[trial]]$Grp)) 
  
  for (i in 1:length(Particles)){
    Temp_particle <- FS_Trial_clean[[trial]][which(
    FS_Trial_clean[[trial]]$Grp == Particles[i]),] %>%
      filter(WF_tx_pcent < 100) 
    
    if (nrow(Temp_particle) <= 1) {
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_angle")]][j] <- 
        NA
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_curvature")]][j] <- 
        NA
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tx_pcent")]][j] <- 
        NA
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tx")]][j] <-
        NA
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_ty")]][j] <- 
        NA
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tz")]][j] <- 
        NA
      
  }
  else{
        for (j in (1+span):(nrow(Temp_particle)-(span))){
      A <- unlist(Temp_particle[(j-span),1:3])
      B <- unlist(Temp_particle[j,1:3])
      C <- unlist(Temp_particle[(j+span),1:3]) 

      A[2] <- 0 #delete y coordinate (to visualise only the mediolateral motions)
      B[2] <- 0
      C[2] <- 0
      
      name <- str_replace(string = Particles[i], pattern =  "_data.tx",
                          replacement = "" )
      
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_angle")]][j] <-
  as.vector(compute_divergence(A,B,C)[1])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_curvature")]][j] <-
  as.vector(compute_divergence(A,B,C)[2])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tx_pcent")]][j] <-
  unlist(Temp_particle $ WF_tx_pcent[j])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tx")]][j] <-
  unlist(Temp_particle[j,1])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_ty")]][j] <-
  unlist(Temp_particle[j,2])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tz")]][j] <-
  unlist(Temp_particle[j,3]) 
        }
  }
  }
}

Divergence_clean <- Divergence

Divergence_clean[["T2P1T10"]] <- NULL # we delete "T2P1T10" trial because the 
# food is not swallowed by the fish

```

We need to transform the Divergence list into a data.frame with the particle 
name, angle, curvature, tx, tx_pcent, and tz.  


```{r}

Divergence_df_list <- unlist(unlist(Divergence_clean, recursive = FALSE), 
                             recursive = FALSE)

# we divide between angle, tx, tx_pcent, and tz (same length):
Divergence_df_angle <- map(.x = str_which(string = names(Divergence_df_list),
                                          pattern = "angle"), 
                           .f = ~get_sublist(lst = Divergence_df_list, 
                                             group_name =
                                               names(Divergence_df_list)[[.]]))

Divergence_df_curvature <- map(.x = str_which(string = names(Divergence_df_list),
                                    pattern = "curvature"), 
                               .f = ~get_sublist(lst = Divergence_df_list,
                                     group_name =
                                       names(Divergence_df_list)[[.]]))

Divergence_df_tx_pcent <- map(.x = str_which(string = names(Divergence_df_list), 
                                             pattern = "_tx_pcent"), 
                              .f = ~get_sublist(lst = Divergence_df_list,
                                     group_name =
                                       names(Divergence_df_list)[[.]]))


Divergence_df_tx <- map(.x = str_which(string = names(Divergence_df_list), 
                                       pattern = "_tx"), 
                        .f = ~get_sublist(lst = Divergence_df_list,
                                          group_name = 
                                            names(Divergence_df_list)[[.]]))

Divergence_df_ty <- map(.x = str_which(string = names(Divergence_df_list), 
                                       pattern = "_ty"),
                        .f = ~get_sublist(lst = Divergence_df_list,
                                          group_name = 
                                            names(Divergence_df_list)[[.]]))

Divergence_df_tz <- map(.x = str_which(string = names(Divergence_df_list), 
                                       pattern = "_tz"), 
                        .f = ~get_sublist(lst = Divergence_df_list,
                                          group_name = 
                                            names(Divergence_df_list)[[.]]))


Divergence_df <- data.frame(particle = str_sub(string = 
                                melt(Divergence_df_angle)[,2], 
                                start = 21, 
                                end = (nchar(melt(Divergence_df_angle)[,2])-6)),
                            angle = melt(Divergence_df_angle)[,1],
                            curvature = melt(Divergence_df_curvature)[,1],
                            tx_pcent= melt(Divergence_df_tx_pcent)[,1], 
                            tx= melt(Divergence_df_tx)[,1], 
                            ty= melt(Divergence_df_ty)[,1],
                            tz= melt(Divergence_df_tz)[,1] )

# we add a column with the item category:
Divergence_df <- Divergence_df %>% 
  mutate(item = case_when(str_detect(string = particle, pattern = "F") ~ "W", 
                          str_detect(string = particle, pattern = "A") ~ "F"))


```


##### Average of food and water tracers angle on a small span of tx

To compare the curvature of each tracer at different levels of the buccal 
cavity, we average the food and water tracers curvature on a small span of tx.


###### Data preparation in Carp

```{r}

# split between carp and tilapia
 Divergence_df_carp <-  Divergence_df %>% 
  filter(str_detect(string = particle, pattern = "C"))
  
 Divergence_df_tilapia <-  Divergence_df %>% 
   filter(str_detect(string = particle, pattern = "C", negate = TRUE)) 

 # Carp 
 
# split between water and food particles
Divergence_df_water_carp <-  Divergence_df_carp %>% filter(item == "W") %>% 
  filter(tx_pcent > 1 & tx_pcent < 75)%>% arrange(desc(tx_pcent))
Divergence_df_food_carp <-  Divergence_df_carp %>% filter(item == "F") %>% 
  filter(tx_pcent > 1 & tx_pcent < 75)%>% arrange(desc(tx_pcent)) 

 # we cut by the number of intervals we want (5 intervals)
 
breaks <- seq(from = 0, to = 75, by = 15)

 # water -----------------
Curvature_interval_water_carp <-  Divergence_df_water_carp %>% 
  mutate(interval = cut(tx_pcent,
                          breaks, 
                          include.lowest = TRUE, 
                          right = FALSE)) %>% group_by(interval) 
 
 
 Curvature_interval_water_mean_carp <-  Curvature_interval_water_carp %>%  
    summarise( mean.curvature = mean(curvature, na.rm=TRUE),
               sd.curvature = sd(curvature, na.rm=TRUE) )
 

 # food -----------------
Curvature_interval_food_carp <- Divergence_df_food_carp %>% 
    mutate(interval = cut(tx_pcent,
                          breaks, 
                          include.lowest = TRUE, 
                          right = FALSE)) %>% group_by(interval) 

 Curvature_interval_food_mean_carp <- Curvature_interval_food_carp %>% 
   summarise( mean.curvature = mean(curvature, na.rm=TRUE) , 
              sd.curvature = sd(curvature, na.rm=TRUE) )

 
# merge water and food particles
 Curvature_interval_carp<-  rbind(Curvature_interval_water_carp,
                             Curvature_interval_food_carp) %>% 
   arrange(desc(interval)) %>% 
 mutate(item = case_when(str_detect(string = particle, pattern = "F") ~ "W", 
                           str_detect(string = particle, pattern = "A") ~ "F"))
 
```

###### Data preparation in Tilapia

```{r}
 # Tilapia 
 
# split between water and food particles
Divergence_df_water_tilapia <-  
  Divergence_df_tilapia %>% 
  filter(item == "W") %>% 
  filter(tx_pcent > 0 & tx_pcent < 75)%>% 
  arrange(desc(tx_pcent))

Divergence_df_food_tilapia <-  Divergence_df_tilapia %>% 
  filter(item == "F") %>% 
  filter(tx_pcent > 0 & tx_pcent < 75)%>% 
  arrange(desc(tx_pcent)) 
# %>%  filter(str_detect(string = particle, pattern = "T2P1T10", negate = TRUE))

# we cut by the number of intervals we want (5 intervals)
 
breaks <- seq(from = 0, to = 75, by = 15)

# water -----------------
Curvature_interval_water_tilapia <- Divergence_df_water_tilapia %>% 
    mutate(interval = cut(tx_pcent,
                          breaks, 
                          include.lowest = TRUE, 
                          right = FALSE)) %>% group_by(interval)
Curvature_interval_water_mean_tilapia <-  Curvature_interval_water_tilapia %>%  
  summarise( mean.curvature = mean(curvature, na.rm=TRUE),
             sd.curvature = sd(curvature, na.rm=TRUE) )

 # food -----------------
Curvature_interval_food_tilapia <- Divergence_df_food_tilapia %>% 
    mutate(interval = cut(tx_pcent,
                          breaks, 
                          include.lowest = TRUE, 
                          right = FALSE)) %>% group_by(interval) 

 Curvature_interval_food_mean_tilapia <- Curvature_interval_food_tilapia %>% 
   summarise( mean.curvature = mean(curvature, na.rm=TRUE) , 
              sd.curvature = sd(curvature, na.rm=TRUE) )

 
# merge water and food particles
 Curvature_interval_tilapia<-  rbind(Curvature_interval_water_tilapia,
                             Curvature_interval_food_tilapia) %>% 
   arrange(desc(interval)) %>% 
 mutate(item = case_when(str_detect(string = particle, pattern = "F") ~ "W", 
                           str_detect(string = particle, pattern = "A") ~ "F"))

```


##### Visualisation
Now that we have the angle for intervals of tx for the water and the food items, 
we organize the data by Species and visualize the difference between each item 
(Figure 4 in the manuscript), in both species.


```{r , fig.width=5, fig.show='hold',fig.align='center'}
  #Carp data:
  color <- c(palette_IOFLOW[13], # grey
             palette_IOFLOW[5]   # blue
  )
  
  
   ggplot(Curvature_interval_carp, aes(x=interval, y=curvature, 
                                                    fill=item)) +
    geom_boxplot(notch=TRUE
                 , outlier.shape = NA
                 #, outlier.shape=8,  outlier.size=4
    ) +
    labs(x="percentage of tx", y = expression(curvature~(cm^-1))) + 
    scale_color_manual(values = color)+
    scale_fill_manual(values =  color)+ labs(subtitle = "Carp" )+
    theme_minimal() +
    stat_summary(fun=mean, geom="point", size=1, col = "white",
                 position = position_dodge(0.75)) +
    theme(legend.position = "none") + 
    ylim(-0.25,2) 

    

```


```{r, fig.width=5, fig.show='hold',fig.align='center'}
  # Tilapia data:
  color <- c(palette_IOFLOW[13], # grey
             palette_IOFLOW[5]   # blue
  )
  
  
   ggplot(Curvature_interval_tilapia, aes(x=interval, y=curvature, 
                                                    fill=item)) +
 
     geom_boxplot(notch=TRUE
                 , outlier.shape = NA
                 #, outlier.shape=8,  outlier.size=4
    ) +
    labs(x="percentage of tx", y = expression(curvature~(cm^-1))) + 
    scale_color_manual(values = color)+
    scale_fill_manual(values =  color)+ labs(subtitle = "Tilapia" )+
    theme_minimal() +
    stat_summary(fun=mean, geom="point", size=1, col = "white",
                 position = position_dodge(0.75)) +
    theme(legend.position = "none") + 
    ylim(-0.25,2) 


```


##### Statistical test

We perform a kruskal test on each interval as the distribution of the data 
was not normal.


```{r}
# Carp
Intervals <- levels(Curvature_interval_carp$interval)

kruskal.test_results_Carp_ML <- map(.x = Intervals, 
                            .f = ~(kruskal.test(curvature ~ item,
                                          data = filter(.data = Curvature_interval_carp, interval== .)))) %>% 
  set_names(Intervals)

kruskal.test_p_value_Carp_ML <-map(.x = Intervals, 
                           .f = ~get_sublist(lst = kruskal.test_results_Carp_ML[[.]], 
                                             group_name = "p.value")) %>%
  set_names(Intervals)

print(kruskal.test_p_value_Carp_ML)

# Tilapia 
Intervals <- levels(Curvature_interval_tilapia$interval)
kruskal.test_results_Tilapia_ML <- map(.x = Intervals, 
                            .f = ~(kruskal.test(curvature ~ item,
                                          data = filter(.data = Curvature_interval_tilapia, interval== .)))) %>% 
  set_names(Intervals)


kruskal.test_p_value_Tilapia_ML <-map(.x = Intervals, 
                           .f = ~get_sublist(lst = kruskal.test_results_Tilapia_ML[[.]],
                                             group_name = "p.value")) %>%
  set_names(Intervals)
print(kruskal.test_p_value_Tilapia_ML)

```



#### Dorsoventral motions

We repeat the same analysis on the Dorsoventral motions (not shown in the 
manuscript). 


```{r}
Divergence <- list()
span <- 1 # for each frame

for(trial in Trials){
  Particles <- levels(factor(FS_Trial_clean[[trial]]$Grp)) 
  
  for (i in 1:length(Particles)){
    Temp_particle <- FS_Trial_clean[[trial]][which(
    FS_Trial_clean[[trial]]$Grp == Particles[i]),] %>%
      filter(WF_tx_pcent < 100) 
    
    if (nrow(Temp_particle) <= 1) {
  Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_angle")]][j] <- 
    NA
  Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_curvature")]][j] <-
    NA
  Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tx_pcent")]][j] <-
    NA
  Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tx")]][j] <- 
    NA
  Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_ty")]][j] <- 
    NA
  Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tz")]][j] <- 
    NA
      
  }
  else{
        for (j in (1+span):(nrow(Temp_particle)-(span))){
      A <- unlist(Temp_particle[(j-span),1:3])
      B <- unlist(Temp_particle[j,1:3])
      C <- unlist(Temp_particle[(j+span),1:3]) 

      A[3] <- 0 # we delete the z coordinate to calculate the divergence data in 
      # the lateral view (dorso-ventral motions)
      B[3] <- 0
      C[3] <- 0
      
      name <- str_replace(string = Particles[i], pattern =  "_data.tx", 
                          replacement = "" )
    
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_angle")]][j] <-
  as.vector(compute_divergence(A,B,C)[1])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_curvature")]][j] <-
  as.vector(compute_divergence(A,B,C)[2])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tx_pcent")]][j] <-
  unlist(Temp_particle $ WF_tx_pcent[j])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tx")]][j] <-
  unlist(Temp_particle[j,1])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_ty")]][j] <-
  unlist(Temp_particle[j,2])
Divergence[[names(Maya_WF)[trial]]][[name]][[paste0(name, "_tz")]][j] <-
  unlist(Temp_particle[j,3]) 
        }
  }
  }
}


Divergence_clean <- Divergence

Divergence_clean[["T2P1T10"]] <- NULL

```

We need to transform the Divergence list into a data.frame with the particle
name, angle, curvature, tx, tx_pcent, and tz.  


```{r}

Divergence_df_list <- unlist(unlist(Divergence_clean, recursive = FALSE),
                             recursive = FALSE)

# we divide between angle, tx, tx_pcent, and tz (same length):
Divergence_df_angle <- map(.x = str_which(string = names(Divergence_df_list),
                                          pattern = "angle"), 
                           .f = ~get_sublist(lst = Divergence_df_list, 
                                  group_name = names(Divergence_df_list)[[.]]))

Divergence_df_curvature <- map(.x = str_which(string = 
                                                names(Divergence_df_list),
                                              pattern = "curvature"), 
                               .f = ~get_sublist(lst = Divergence_df_list, 
                                  group_name = names(Divergence_df_list)[[.]]))

Divergence_df_tx_pcent <- map(.x = str_which(string = names(Divergence_df_list),
                                             pattern = "_tx_pcent"),
                              .f = ~get_sublist(lst = Divergence_df_list, 
                                  group_name = names(Divergence_df_list)[[.]]))

Divergence_df_tz <- map(.x = str_which(string = names(Divergence_df_list),
                                       pattern = "_tz"), .f = ~get_sublist(lst = Divergence_df_list, group_name = names(Divergence_df_list)[[.]]))


Divergence_df <- data.frame(particle = str_sub(string =
                                                 melt(Divergence_df_angle)[,2], 
                         start = 21, 
                         end = (nchar(melt(Divergence_df_angle)[,2])-6)),
      angle = melt(Divergence_df_angle)[,1],
      curvature = melt(Divergence_df_curvature)[,1],
      tx_pcent= melt(Divergence_df_tx_pcent)[,1], 
      tz= melt(Divergence_df_tz)[,1] )

# we add a column with the item category:
Divergence_df <- Divergence_df %>%
  mutate(item = case_when(str_detect(string = particle, pattern = "F") ~ "W", 
                          str_detect(string = particle, pattern = "A") ~ "F"))
   
```


#### Average of food and water tracer angle on a small span of tx

##### Data preparation in Carp

```{r}

# split between carp and tilapia
Divergence_df_carp <-  Divergence_df %>% filter(str_detect(string = particle, pattern = "C"))
  
 Divergence_df_tilapia <-  Divergence_df %>% filter(str_detect(string = particle, pattern = "C", negate = TRUE)) 


# Carp 
 
# split between water and food particles
Divergence_df_water_carp <-  Divergence_df_carp %>% 
  filter(item == "W") %>% 
  filter(tx_pcent > 1 & tx_pcent < 75)%>% 
  arrange(desc(tx_pcent))
Divergence_df_food_carp <-  Divergence_df_carp %>% 
  filter(item == "F") %>% 
  filter(tx_pcent > 1 & tx_pcent < 75)%>%
  arrange(desc(tx_pcent)) 
# %>%  filter(str_detect(string = particle, pattern = "T2P1T10", negate = TRUE))

# we cut by the number of intervals we want (5 intervals)
 
breaks <- seq(from = 0, to = 75, by = 15)

# water -----------------
Curvature_interval_water_carp <- Divergence_df_water_carp %>% 
    mutate(interval = cut(tx_pcent,
                          breaks, 
                          include.lowest = TRUE, 
                          right = FALSE)) %>% group_by(interval)
Curvature_interval_water_mean_carp <-  Curvature_interval_water_carp %>%  
  summarise( mean.curvature = mean(curvature, na.rm=TRUE),
             sd.curvature = sd(curvature, na.rm=TRUE) )

 # food -----------------
Curvature_interval_food_carp <- Divergence_df_food_carp %>% 
    mutate(interval = cut(tx_pcent,
                          breaks, 
                          include.lowest = TRUE, 
                          right = FALSE)) %>% group_by(interval) 

 Curvature_interval_food_mean_carp <- Curvature_interval_food_carp %>% 
   summarise( mean.curvature = mean(curvature, na.rm=TRUE) , 
              sd.curvature = sd(curvature, na.rm=TRUE) )

 
# merge water and food particles
 Curvature_interval_carp<-  rbind(Curvature_interval_water_carp,
                             Curvature_interval_food_carp) %>% 
   arrange(desc(interval)) %>% 
 mutate(item = case_when(str_detect(string = particle, pattern = "F") ~ "W", 
                           str_detect(string = particle, pattern = "A") ~ "F"))

```

##### Data preparation in Tilapia

```{r}

 
 # tilapia 
 
# split between water and food particles
Divergence_df_water_tilapia <-  Divergence_df_tilapia %>% 
  filter(item == "W") %>% 
  filter(tx_pcent > 20 & tx_pcent < 75)%>% 
  arrange(desc(tx_pcent))
Divergence_df_food_tilapia <-  Divergence_df_tilapia %>% filter(item == "F") %>% 
  filter(tx_pcent > 20 & tx_pcent < 75)%>% arrange(desc(tx_pcent)) 
# %>%  filter(str_detect(string = particle, pattern = "T2P1T10", negate = TRUE))

# we cut by the number of intervals we want (5 intervals)
 
breaks <- seq(from = 15, to = 75, by = 15)

# water -----------------
Curvature_interval_water_tilapia <- Divergence_df_water_tilapia %>% 
    mutate(interval = cut(tx_pcent,
                          breaks, 
                          include.lowest = TRUE, 
                          right = FALSE)) %>% group_by(interval)
Curvature_interval_water_mean_tilapia <-  Curvature_interval_water_tilapia %>%  
  summarise( mean.curvature = mean(curvature, na.rm=TRUE),
             sd.curvature = sd(curvature, na.rm=TRUE) )

 # food -----------------
Curvature_interval_food_tilapia <- Divergence_df_food_tilapia %>% 
    mutate(interval = cut(tx_pcent,
                          breaks, 
                          include.lowest = TRUE, 
                          right = FALSE)) %>% group_by(interval) 

 Curvature_interval_food_mean_tilapia <- Curvature_interval_food_tilapia %>% 
   summarise( mean.curvature = mean(curvature, na.rm=TRUE) , 
              sd.curvature = sd(curvature, na.rm=TRUE) )

 
# merge water and food particles
 Curvature_interval_tilapia<-  rbind(Curvature_interval_water_tilapia,
                             Curvature_interval_food_tilapia) %>% 
   arrange(desc(interval)) %>% 
 mutate(item = case_when(str_detect(string = particle, pattern = "F") ~ "W", 
                           str_detect(string = particle, pattern = "A") ~ "F"))

```


#### Visualisation
Now that we have the angle for intervals of tx for the water and the food items,
we organize the data by Species and visualize the difference between each item.


```{r , fig.width=5, fig.show='hold',fig.align='center'}
 #Carp data:
  color <- c(palette_IOFLOW[13], # grey
             palette_IOFLOW[5]   # blue
  )
  
  
   ggplot(Curvature_interval_carp, aes(x=interval, y=curvature, 
                                                    fill=item)) +
    geom_boxplot(notch=TRUE
                 , outlier.shape = NA
                 #, outlier.shape=8,  outlier.size=4
    ) +
    labs(x="percentage of tx", y = expression(curvature~(m^-1))) + 
    scale_color_manual(values = color)+
    scale_fill_manual(values =  color)+ labs(subtitle = "Carp" )+
    theme_minimal() +
    stat_summary(fun=mean, geom="point", size=1, col = "white",
                 position = position_dodge(0.75)) +
    theme(legend.position = "none") + ylim(-0.5,2) 
   
```
   

```{r, fig.width=5, fig.show='hold',fig.align='center'}
 # Tilapia data:
  color <- c(palette_IOFLOW[13], # grey
             palette_IOFLOW[5]   # blue
  )
  
  
   ggplot(Curvature_interval_tilapia, aes(x=interval, y=curvature, 
                                                    fill=item)) +
 
     geom_boxplot(notch=TRUE
                 , outlier.shape = NA
                 #, outlier.shape=8,  outlier.size=4
    ) +
    labs(x="percentage of tx", y = expression(curvature~(m^-1))) + 
    scale_color_manual(values = color)+
    scale_fill_manual(values =  color)+ labs(subtitle = "Tilapia" )+
    theme_minimal() +
    stat_summary(fun=mean, geom="point", size=1, col = "white",
                 position = position_dodge(0.75)) +
    theme(legend.position = "none") + 
    ylim(-0.5,2) 

```
    


#### Statistical test

We perform a kruskal test on each interval.

```{r}
# Carp
Intervals <- levels(Curvature_interval_carp$interval)

kruskal.test_results_Carp_DV <- map(.x = Intervals, 
                            .f = ~(kruskal.test(curvature ~ item,
                                          data = filter(.data = Curvature_interval_carp, interval== .)))) %>% 
  set_names(Intervals)

kruskal.test_p_value_Carp_DV <-map(.x = Intervals, 
                           .f = ~get_sublist(lst = kruskal.test_results_Carp_DV[[.]], 
                                             group_name = "p.value")) %>%
  set_names(Intervals)

print(kruskal.test_p_value_Carp_DV)
# Tilapia 
Intervals <- levels(Curvature_interval_tilapia$interval)
kruskal.test_results_Tilapia_DV <- map(.x = Intervals, 
                            .f = ~(kruskal.test(curvature ~ item,
                                          data = filter(.data = Curvature_interval_tilapia, interval== .)))) %>% 
  set_names(Intervals)


kruskal.test_p_value_Tilapia_DV <-map(.x = Intervals, 
                           .f = ~get_sublist(lst = kruskal.test_results_Tilapia_DV[[.]], group_name = "p.value")) %>%
  set_names(Intervals)

print(kruskal.test_p_value_Tilapia_DV)

```

## Initial vs Final location

To see the influence of the initial position of the tracer on their final position, we visualize the trajectories on the dorsoventral view (tx, tz) and color the trajectories based on the initial location.

```{r}

# Carp2

# Selection of the 3D data for the carp02
Carp2_3D <- FS %>% 
  filter(str_detect(string = Trials , pattern = "C2P"))


# Selection of the position at t=0 for each tracer of both individuals
Initial_carp2 <- Carp2_3D %>% 
  group_by(Grp) %>% 
    slice(which.min(Time)) %>% 
  arrange(WF_tz) %>% 
  rowid_to_column(var='Color')
 
# generate a color palette

p2 <- viridis(length(levels(as.factor(Initial_carp2$Grp)))/2)

# make the palette symmetrical

p2_sym <- c(rev(p2), p2)

 for (i in 1:length(levels(as.factor(Initial_carp2$Grp)))){
  Carp2_3D[which(Carp2_3D$Grp == Initial_carp2$Grp[i]),11] <- p2_sym[i]
}

colnames(Carp2_3D)[11] <- "Color"

plot_Carp2 <- ggplot(data = Carp2_3D,
         aes(
           x = -WF_tx,
           y = WF_tz)) +
     geom_point(aes(colour = Color), size = 1) +
    ylab("tz (cm)") +
    xlab("tx (cm)") +
  # ggtitle("Carp02") +
    scale_color_manual(values = p2_sym)+
    scale_fill_manual(values =  p2_sym)+
     theme_minimal()+
    theme(legend.position = "none") 

plot_Carp2


# Carp1

# Selection of the 3D data for the carp
Carp1_3D <- FS %>% 
  filter(str_detect(string = Trials , pattern = "C1P"))

# Selection of the position at t=0 for each tracer of both individuals
Initial_carp1 <- Carp1_3D %>% 
  group_by(Grp) %>% 
    slice(which.min(Time)) %>% 
  arrange(WF_tz) %>% 
  rowid_to_column(var='Color')
 

# generate a color palette

p2 <- viridis(length(levels(as.factor(Initial_carp1$Grp)))/2)

# make the palette symmetrical

p2_sym <- c(rev(p2), p2)


 for (i in 1:length(levels(as.factor(Initial_carp1$Grp)))){
  
Carp1_3D[which(Carp1_3D$Grp == Initial_carp1$Grp[i]),11] <- p2_sym[i]
}

colnames(Carp1_3D)[11] <- "Color"


plot_Carp1 <- ggplot(data = Carp1_3D,
         aes(
           x = -WF_tx,
           y = WF_tz)) +
     geom_point(aes(colour = Color), size = 1) +
    ylab("tz (cm)") +
    xlab("tx (cm)") +
  # ggtitle("Carp01") +
    scale_color_manual(values = p2_sym)+
    scale_fill_manual(values =  p2_sym)+
     theme_minimal()+
    theme(legend.position = "none") 

plot_Carp1


# Tilapia2 

# Selection of the 3D data for the tilapia
Tilapia2_3D <- FS %>% 
  filter(str_detect(string = Trials , pattern = "T2P"))


# Selection of the position at t=0 for each tracer of both individuals
Initial_tilapia2 <- Tilapia2_3D %>% 
  group_by(Grp) %>% 
    slice(which.min(Time)) %>% 
  arrange(WF_tz) %>% 
  rowid_to_column(var='Color')
 

# generate a color palette

p2 <- viridis(length(levels(as.factor(Initial_tilapia2$Grp)))/2)

# make the palette symmetrical

p2_sym <- c(rev(p2), p2)


for (i in 1:length(levels(as.factor(Initial_tilapia2$Grp)))){
  
Tilapia2_3D[which(Tilapia2_3D$Grp == Initial_tilapia2$Grp[i]),11] <- p2_sym[i]

}

colnames(Tilapia2_3D)[11] <- "Color"


plot_Tilapia2 <- ggplot(data = Tilapia2_3D,
         aes(
           x = -WF_tx,
           y = WF_tz)) +
     geom_point(aes(colour = Color), size = 1) +
    ylab("tz (cm)") +
    xlab("tx (cm)") +
  # ggtitle("Tilapia02") +
    scale_color_manual(values = p2_sym)+
    scale_fill_manual(values =  p2_sym)+
     theme_minimal()+
    theme(legend.position = "none") 

plot_Tilapia2

# Tilapia1

# Selection of the 3D data for the tilapia
Tilapia1_3D <- FS %>% 
  filter(str_detect(string = Trials , pattern = "T1P"))


# Selection of the position at t=0 for each tracer of both individuals
Initial_tilapia1 <- Tilapia1_3D %>% 
  group_by(Grp) %>% 
    slice(which.min(Time)) %>% 
  arrange(WF_tz) %>% 
  rowid_to_column(var='Color')
 

# generate a color palette

p2 <- viridis(length(levels(as.factor(Initial_tilapia1$Grp)))/2)

# make the palette symmetrical

p2_sym <- c(rev(p2), p2)

for (i in 1:length(levels(as.factor(Initial_tilapia1$Grp)))){
  
Tilapia1_3D[which(Tilapia1_3D$Grp == Initial_tilapia1$Grp[i]),11] <- p2_sym[i]
}

colnames(Tilapia1_3D)[11] <- "Color"


plot_Tilapia1 <- ggplot(data = Tilapia1_3D,
         aes(
           x = -WF_tx,
           y = WF_tz)) +
     geom_point(aes(colour = Color), size = 1) +
    ylab("tz (cm)") +
    xlab("tx (cm)") +
  # ggtitle("Tilapia01") +
    scale_color_manual(values = p2_sym)+
    scale_fill_manual(values =  p2_sym)+
     theme_minimal()+
    theme(legend.position = "none") 

plot_Tilapia1

# 
# 
# graphs <- list(plot_Tilapia1, plot_Tilapia2, plot_Carp1, plot_Carp2)
# for (i in 1:4){
# 
#   png(paste0("../1.Figures/",i, "_xz.png"), width = 300,height =  200, units = "px", bg = "transparent")
#     print(graphs[[i]])
#     dev.off()
# 
# }

```


### Statistical test

We want to check if there is a significant correlation between the location of the particle at the beginning of the intake and the location at the end of the intake.


```{r}
# Selection of the position at t=0 for each tracer of both individuals

# carp

# Selection of the 3D data for the carp
Carp_3D <- FS %>% 
  filter(str_detect(string = Trials , pattern = "C1P|C2P")) %>%
      arrange(Time, WF_tz)
 

Initial_carp <- Carp_3D %>% 
  group_by(Grp) %>% 
    slice(which.min(Time)) %>%  # at the beginning
  select(WF_tx, WF_ty, WF_tz, Time, Grp) %>% 
  rename(WF_tx_init = WF_tx,
         WF_ty_init = WF_ty,
         WF_tz_init = WF_tz,
         Time_init = Time)

Final_carp <- Carp_3D %>% 
  group_by(Grp) %>% 
    slice(which.max(Time)) %>%  # at the end
  select(WF_tx, WF_ty, WF_tz, Time, Grp) %>% 
  rename(WF_tx_fin = WF_tx,
         WF_ty_fin = WF_ty,
         WF_tz_fin = WF_tz,
         Time_fin = Time)


# Correlation test

shapiro.test(Initial_carp$WF_tz_init)

shapiro.test(Final_carp$WF_tz_fin)

  
correl_carp <- cor.test(Initial_carp$WF_tz_init, Final_carp$WF_tz_fin, method ="kendall")

correl_carp


# tilapia

# Selection of the 3D data for the tilapia
Tilapia_3D <- FS %>% 
  filter(str_detect(string = Trials , pattern = "T1P|T2P")) %>%
      arrange(Time, WF_tz)
 

Initial_tilapia <- Tilapia_3D %>% 
  group_by(Grp) %>% 
    slice(which.min(Time)) %>%  # at the beginning
  select(WF_tx, WF_ty, WF_tz, Time, Grp) %>% 
  rename(WF_tx_init = WF_tx,
         WF_ty_init = WF_ty,
         WF_tz_init = WF_tz,
         Time_init = Time)

Final_tilapia <- Tilapia_3D %>% 
  group_by(Grp) %>% 
    slice(which.max(Time)) %>%  # at the end
  select(WF_tx, WF_ty, WF_tz, Time, Grp) %>% 
  rename(WF_tx_fin = WF_tx,
         WF_ty_fin = WF_ty,
         WF_tz_fin = WF_tz,
         Time_fin = Time)


# Correlation test

shapiro.test(Initial_tilapia$WF_tz_init)

shapiro.test(Final_tilapia$WF_tz_fin)

  
correl_tilapia <- cor.test(Initial_tilapia$WF_tz_init, Final_tilapia$WF_tz_fin, method ="kendall") 

correl_tilapia


```

The calculation of Kendall's correlation coefficient, based on a rank test, should be used because the data does not come from a normal distribution.

For the tilapia, the kendall test of correlation between the initial and final location of the particle is not significant (p value = `r round(correl_tilapia$p.value, digits = 2) `.

For the carp, the kendall test of correlation  between the initial and final location of the particle is significant (p value = `r round(correl_carp$p.value, digits = 2) `. The correlation coefficient is `r round(correl_carp$statistic, digits = 2) `.


## Link between moment of ingestion (tx location at 25% duration) and trajectory in the buccal cavity

We want to see if there is a link between the moment tracers are ingested and their trajectory inside the buccal cavity: do early-sucked particles tend to stay in the medial plane of the buccal cavity, whereas the late ones tend to end up on the lateral parts of the buccal cavity?

### Visualisation

```{r}
# Carp "C2P1T04"

# Selection of the 3D data for the carp
Carp2_velocity <- FS %>% 
  filter(str_detect(string = Trials , pattern = "C2P1T04"))

# Selection of the velocity at frame = 250 for each tracer of both individuals
Initial_carp2_velocity <- Carp2_velocity %>% 
  group_by(Grp) %>% 
   slice( which(Frame == Frame[floor(length(Frame)/4)])) %>% 
  arrange(WF_tx) %>% 
  rowid_to_column(var='Color')
 
p2 <- magma(length(levels(as.factor(Initial_carp2_velocity$Grp))))

for (i in 1:length(levels(as.factor(Initial_carp2_velocity$Grp)))){
  
Carp2_velocity[which(Carp2_velocity$Grp == Initial_carp2_velocity$Grp[i]),11] <- p2[i]
}

colnames(Carp2_velocity)[11] <- "Color"


plot_Carp2_velocity <- ggplot(data = Carp2_velocity,
         aes(
           x = -WF_tx,
           y = WF_tz)) +
      geom_point(aes(colour = Color), size = 1) +
    ylab("z") +
    xlab("x") +
  ggtitle("Carp02") +
    scale_color_manual(values = p2)+
    scale_fill_manual(values =  p2)+
     theme_minimal()+
    theme(legend.position = "none") 

plot_Carp2_velocity

# Tilapia "T1P1T06"

# Selection of the 3D data for the carp
Tilapia1_velocity <- FS %>% 
  filter(str_detect(string = Trials , pattern = "T1P1T06"))


# Selection of the velocity at frame = 25% of the intake duration for each tracer of both individuals
Initial_tilapia1_velocity <- Tilapia1_velocity %>% 
  group_by(Grp) %>% 
   slice( which(Frame == Frame[floor(length(Frame)/4)])) %>% 
  arrange(WF_tx) %>% 
  rowid_to_column(var='Color')
 
p2 <- magma(length(levels(as.factor(Initial_tilapia1_velocity$Grp))))

for (i in 1:length(levels(as.factor(Initial_tilapia1_velocity$Grp)))){
  
Tilapia1_velocity[which(Tilapia1_velocity$Grp == Initial_tilapia1_velocity$Grp[i]),11] <- p2[i]
}

colnames(Tilapia1_velocity)[11] <- "Color"


plot_Tilapia1_velocity <- ggplot(data = Tilapia1_velocity,
         aes(
           x = -WF_tx,
           y = WF_tz)) +
      geom_point(aes(colour = Color), size = 1) +
    ylab("z") +
    xlab("x") +
  ggtitle("Tilapia01") +
    scale_color_manual(values = p2)+
    scale_fill_manual(values =  p2)+
     theme_minimal()+
    theme(legend.position = "none") 

plot_Tilapia1_velocity

```

### Statistics

```{r}

# Selection of the position at t=25% for each tracer of both individuals

# carp

# Selection of the 3D data for the carp
Carp_3D <- FS %>% 
  filter(str_detect(string = Trials , pattern = "C2P|C1P")) %>%
      arrange(Time, WF_tz)
 

Initial_carp_25 <- Carp_3D %>% 
  group_by(Grp) %>% 
   slice( which(Frame == Frame[floor(length(Frame)/4)])) %>% # at t= 25 %
  select(WF_tx, WF_ty, WF_tz, Time, Grp) %>% 
  rename(WF_tx_init = WF_tx,
         WF_ty_init = WF_ty,
         WF_tz_init = WF_tz,
         Time_init = Time)

Final_carp <- Carp_3D %>% 
  group_by(Grp) %>% 
    slice(which.max(Time)) %>%  # at the end
  select(WF_tx, WF_ty, WF_tz, Time, Grp) %>% 
  rename(WF_tx_fin = WF_tx,
         WF_ty_fin = WF_ty,
         WF_tz_fin = WF_tz,
         Time_fin = Time)


# Correlation test

shapiro.test(Initial_carp_25$WF_tx_init)

shapiro.test(Final_carp$WF_tz_fin)

  
correl_carp_25 <- cor.test(na.omit(Initial_carp_25$WF_tx_init), na.omit(Final_carp$WF_tz_fin), method ="kendall")

correl_carp_25


# tilapia

# Selection of the 3D data for the tilapia
Tilapia_3D <- FS %>% 
  filter(str_detect(string = Trials , pattern = "T1P|T2P")) %>%
      arrange(Time, WF_tz)
 

Initial_tilapia_25 <- Tilapia_3D %>% 
  group_by(Grp) %>% 
   slice( which(Frame == Frame[floor(length(Frame)/4)])) %>% # at t= 25 %
  select(WF_tx, WF_ty, WF_tz, Time, Grp) %>% 
  rename(WF_tx_init = WF_tx,
         WF_ty_init = WF_ty,
         WF_tz_init = WF_tz,
         Time_init = Time)

Final_tilapia <- Tilapia_3D %>% 
  group_by(Grp) %>% 
    slice(which.max(Time)) %>%  # at the end
  select(WF_tx, WF_ty, WF_tz, Time, Grp) %>% 
  rename(WF_tx_fin = WF_tx,
         WF_ty_fin = WF_ty,
         WF_tz_fin = WF_tz,
         Time_fin = Time)


# Correlation test

shapiro.test(Initial_tilapia_25$WF_tx_init)

shapiro.test(Final_tilapia$WF_tz_fin)

  
correl_tilapia_25 <- cor.test(Initial_tilapia_25$WF_tx_init, Final_tilapia$WF_tz_fin, method ="kendall")

correl_tilapia_25

```

The calculation of Kendall's correlation coefficient, based on a rank test, should be used because the data does not come from a normal distribution.

For the carp, the kendall test of correlation  between the initial and final location of the particle is not significant (p value = `r round(correl_carp_25$p.value, digits = 2)`.

For the tilapia, the kendall test of correlation between the moment of ingestion and the final location of the particle is not significant (p value = `r round(correl_tilapia_25$p.value, digits = 2) `.


# Rigid body kinematics

We want to visualize on the same plot
- Food tx
- Gape (open close) : distance inferior vs posterior
- Hyoid dorsoventral : tip of hyoid relative to pharyngeal jaw (ty)
- Ope opening/closing : tip of ope relative to pharyngeal jaw (tz)

## Data preparation  

### Building Kdata

We want to combine KData (the kinematics data) and MayaData (the tracer 
trajectory data) and add Time, Frame, Phase.


```{r}

Time <- map(.x = Trials[1:10],
             .f = ~as.data.frame(cbind(
              Time = Trajectory[[.]][[1]]$value.Time,
              Frame = Trajectory[[.]][[1]]$value.Frame,              
              Phase = Trajectory[[.]][[1]]$value.Phase        
              )))%>%
  set_names(names(Maya_Loc))
             
Food <- map(.x = Trials[1:10],
            .f = ~(as.data.frame(cbind(
              Mean_tx_F = Mean_tx_F[[.]]$average,
              Mean_ty_F = Mean_ty_F[[.]]$average,              
              Mean_tz_F = Mean_tz_F[[.]]$average              
              )))) %>%
  set_names(names(Maya_Loc))


Water <- map(.x = Trials[1:10],
            .f = ~(as.data.frame(cbind(
              Mean_tx_W = Mean_tx_W[[.]]$average,
              Mean_ty_W = Mean_ty_W[[.]]$average,              
              Mean_tz_W = Mean_tz_W[[.]]$average              
              )))) %>%
  set_names(names(Maya_Loc))


# merging the data:
KData <- mapply(FUN = c, Time, Food, Water, Maya_Loc, SIMPLIFY=FALSE)


```


### Gape calculation

We calculate the Gape, using the locators placed on the tip of the lower and 
upper jaws.

```{r}



Jaws <- map(.x = Trials[1:10],
            .f = ~ (select(
              KData[[.]]$BonesLocators_relative,
              names(KData[[.]]$BonesLocators_relative)
              [contains(match = "jaw_tip_data.t",
                        vars = names(KData[[.]]$BonesLocators_relative))]
            ))) %>%
  set_names(names(Maya_Loc))


Gape <- map(.x = Trials[1:10],
            .f = ~ (as.data.frame(cbind(
              Gape = distance(
                df1 = select(Jaws[[.]], 
                             names(Jaws[[.]])[contains(match = "lower_jaw", 
                                                       vars = names(Jaws[[.]]))]),
                df2 = select(Jaws[[.]], 
                             names(Jaws[[.]])[contains(match = "upper_jaw",
                                                       vars = names(Jaws[[.]]))])))))) %>%
  set_names(names(Maya_Loc))

# merging the data:
KData <- mapply(FUN = c, KData,  Gape, SIMPLIFY=FALSE)

```


## Visualisation

### Carp

We plot the suction feeding sequence of trial C2P1T04 of carp to visualize 
the kinematics of Gape, Hyoid depression and Opercula opening relative to the
water motions.


```{r, fig.width=5, fig.show='hold',fig.align='center'}

# Carp

trial <- "C2P1T04"
subtime <- 1:1592
xlim_inf <- min(subtime)
xlim_sup <- max(subtime)


# Plot 
## Water
color <- c(palette_IOFLOW[13], # grey
           palette_IOFLOW[5]   # blue
) 

# Tx plot
ylab <- "x-position (cm)"
d <- cbind(rbind(Mean_tx_W[[trial]][subtime,],Mean_tx_F[[trial]][subtime,]), 
           timing = Timing[[trial]]$timing[subtime])

plot.Tx_C2P1T04 <- plot_mean(d, ylab=ylab, xlab=xlab, 
                             color = color) + theme(plot.margin = unit(c(0,0,0,0), "lines")) + theme_minimal()+
  theme(legend.position = "none", panel.grid.minor = element_blank()) 


# Bone kinematics

#c4f2ef: blue (gape)
#e9bc70: orange (hyoid)
#eeceee: pink (opercula)

color <- c("#c4f2ef", "#e9bc70", "#eeceee")
size <- 1

KData_df <- as.data.frame(KData[[trial]])
KData_df <- KData_df[subtime,]


KData_plots <-  ggplot(KData_df, aes(x = Time, y = Gape-min(Gape),
                                     colour="#161717")) +
  geom_line(aes(group=1), size=size+0.2#, linetype="dashed"
            ) +
  geom_line(aes(x = Time, y = -BonesLocators_relative.hyoid_tip_data.ty +
                 max(BonesLocators_relative.hyoid_tip_data.ty), colour="#616363", group=1), size=size+0.2) + 
  geom_line(aes(x = Time, y = BonesLocators_relative.ope_tip_data.tz -
                 min(BonesLocators_relative.ope_tip_data.tz),
                           colour="#9ca19e", group=1), size=size) + 
  ylab("Bone kinematics") +
  xlab("time (s)") +
  theme_minimal()+
  theme(legend.position = "none", panel.grid.minor = element_blank()) +
  scale_color_manual(values = color)+
  scale_fill_manual(values =  color)

# plot the combination of the two plots

ggarrange(plot.Tx_C2P1T04+ rremove("x.text") + rremove(object = "xlab") , KData_plots, 
         ncol = 1, nrow = 2, align = "v")

```

### Tilapia

We plot the suction feeding sequence of trial T1P1T06 of tilapia to visualize 
the kinematics of Gape, Hyoid depression and Opercula abduction relative to the 
water motions.


```{r, fig.width=5, fig.show='hold',fig.align='center'}
# Tilapia

trial <- "T1P1T06"
subtime <- 100:1280
subtitle <- " "
xlim_inf <- min(subtime)
xlim_sup <- max(subtime)
d <- cbind(Mean_tx_W[[trial]][subtime,], timing = Timing[[trial]]$timing[subtime])

# Plot 
## Water
color <- c(palette_IOFLOW[13], # grey
           palette_IOFLOW[5]   # blue
) 

# Tx plot
ylab <- "x-position (cm)"
d <- cbind(rbind(Mean_tx_W[[trial]][subtime,],Mean_tx_F[[trial]][subtime,]), 
           timing = Timing[[trial]]$timing[subtime])

plot.Tx_T1P1T06 <- plot_mean(d, ylab=ylab, xlab=xlab, 
                             color = color)  + theme(plot.margin = unit(c(0,0,0,0), "lines")) + theme_minimal()+
  theme(legend.position = "none", panel.grid.minor = element_blank()) 


# Bone kinematics

#c4f2ef: blue (gape)
#e9bc70: orange (hyoid)
#eeceee: pink (opercula)

color <- c("#c4f2ef", "#e9bc70", "#eeceee")
size <- 1


KData_df <- as.data.frame(KData[[trial]])
KData_df <- KData_df[subtime,]


KData_plots <-  ggplot(KData_df, aes(x = Time, y = Gape-min(Gape),
                                     colour="#161717")) +
  geom_line(aes(group=1), size=size+0.2#, linetype="dashed"
            ) +
  geom_line(aes(x = Time, y = -BonesLocators_relative.hyoid_tip_data.ty +
                 max(BonesLocators_relative.hyoid_tip_data.ty), colour="#616363", group=1), size=size+0.2) + 
  geom_line(aes(x = Time, y = -BonesLocators_relative.ope_tip_data.tz +
                 max(BonesLocators_relative.ope_tip_data.tz),
                           colour="#9ca19e", group=1), size=size) + 
  ylab("Bone kinematics") +
  xlab("time (s)") +
  theme_minimal()+
  theme(legend.position = "none", panel.grid.minor = element_blank()) +
  scale_color_manual(values = color)+
  scale_fill_manual(values =  color)
# plot the combination of the two plots

ggarrange(plot.Tx_T1P1T06+ rremove("x.text") + rremove(object = "xlab") , KData_plots, 
         ncol = 1, nrow = 2, align = "v")

```

These graphs correspond to Figure 5 in the manuscript.

